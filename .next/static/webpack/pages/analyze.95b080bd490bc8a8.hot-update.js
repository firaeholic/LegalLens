"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/analyze",{

/***/ "./lib/apiClient.ts":
/*!**************************!*\
  !*** ./lib/apiClient.ts ***!
  \**************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   APIClient: function() { return /* binding */ APIClient; },\n/* harmony export */   apiClient: function() { return /* binding */ apiClient; }\n/* harmony export */ });\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ \"./lib/utils.ts\");\n/* harmony import */ var _config_constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../config/constants */ \"./config/constants.ts\");\n// API Client for LegalLens AI\n\n\nclass APIClient {\n    async request(endpoint) {\n        let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, timeout = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 30000;\n        const controller = new AbortController();\n        const timeoutId = setTimeout(()=>controller.abort(), timeout);\n        try {\n            const response = await fetch(\"\".concat(this.baseURL).concat(endpoint), {\n                ...options,\n                signal: controller.signal,\n                headers: {\n                    ...options.body instanceof FormData ? {} : {\n                        \"Content-Type\": \"application/json\"\n                    },\n                    ...options.headers\n                }\n            });\n            clearTimeout(timeoutId);\n            if (!response.ok) {\n                const errorText = await response.text();\n                let errorData;\n                try {\n                    errorData = JSON.parse(errorText);\n                } catch (e) {\n                    errorData = {\n                        error: errorText\n                    };\n                }\n                throw new _utils__WEBPACK_IMPORTED_MODULE_0__.AppError(this.getErrorCode(response.status), errorData.error || \"HTTP \".concat(response.status, \": \").concat(response.statusText), {\n                    status: response.status,\n                    response: errorData\n                });\n            }\n            const data = await response.json();\n            if (data.error) {\n                throw new _utils__WEBPACK_IMPORTED_MODULE_0__.AppError(_config_constants__WEBPACK_IMPORTED_MODULE_1__.ERROR_CODES.API_TIMEOUT, data.error, data);\n            }\n            return data;\n        } catch (error) {\n            clearTimeout(timeoutId);\n            if (error instanceof _utils__WEBPACK_IMPORTED_MODULE_0__.AppError) {\n                throw error;\n            }\n            if (error instanceof Error) {\n                if (error.name === \"AbortError\") {\n                    throw new _utils__WEBPACK_IMPORTED_MODULE_0__.AppError(_config_constants__WEBPACK_IMPORTED_MODULE_1__.ERROR_CODES.API_TIMEOUT, \"Request timed out\");\n                }\n                if (error.message.includes(\"fetch\")) {\n                    throw new _utils__WEBPACK_IMPORTED_MODULE_0__.AppError(_config_constants__WEBPACK_IMPORTED_MODULE_1__.ERROR_CODES.NETWORK_ERROR, \"Network error occurred\");\n                }\n            }\n            throw new _utils__WEBPACK_IMPORTED_MODULE_0__.AppError(_config_constants__WEBPACK_IMPORTED_MODULE_1__.ERROR_CODES.NETWORK_ERROR, \"An unexpected error occurred\", error);\n        }\n    }\n    getErrorCode(status) {\n        switch(status){\n            case 400:\n                return _config_constants__WEBPACK_IMPORTED_MODULE_1__.ERROR_CODES.INVALID_INPUT;\n            case 408:\n                return _config_constants__WEBPACK_IMPORTED_MODULE_1__.ERROR_CODES.API_TIMEOUT;\n            case 413:\n                return _config_constants__WEBPACK_IMPORTED_MODULE_1__.ERROR_CODES.FILE_TOO_LARGE;\n            case 415:\n                return _config_constants__WEBPACK_IMPORTED_MODULE_1__.ERROR_CODES.UNSUPPORTED_FORMAT;\n            case 429:\n                return _config_constants__WEBPACK_IMPORTED_MODULE_1__.ERROR_CODES.RATE_LIMITED;\n            case 500:\n            case 502:\n            case 503:\n            case 504:\n                return _config_constants__WEBPACK_IMPORTED_MODULE_1__.ERROR_CODES.NETWORK_ERROR;\n            default:\n                return _config_constants__WEBPACK_IMPORTED_MODULE_1__.ERROR_CODES.NETWORK_ERROR;\n        }\n    }\n    // OCR API\n    async extractText(file) {\n        _utils__WEBPACK_IMPORTED_MODULE_0__.logger.info(\"Starting OCR extraction\", {\n            fileName: file.name,\n            fileSize: file.size\n        }, \"apiClient.extractText\");\n        const formData = new FormData();\n        formData.append(\"file\", file);\n        try {\n            const result = await (0,_utils__WEBPACK_IMPORTED_MODULE_0__.retry)(()=>this.request(_config_constants__WEBPACK_IMPORTED_MODULE_1__.API_ENDPOINTS.OCR, {\n                    method: \"POST\",\n                    body: formData,\n                    headers: {} // Remove Content-Type to let browser set it for FormData\n                }, _config_constants__WEBPACK_IMPORTED_MODULE_1__.APP_CONFIG.apiTimeouts.OCR), 2, 2000 // 2 second delay\n            );\n            _utils__WEBPACK_IMPORTED_MODULE_0__.logger.info(\"OCR extraction completed\", {\n                textLength: result.text.length,\n                confidence: result.confidence,\n                method: result.method\n            }, \"apiClient.extractText\");\n            return result;\n        } catch (error) {\n            _utils__WEBPACK_IMPORTED_MODULE_0__.logger.error(\"OCR extraction failed\", error, \"apiClient.extractText\");\n            throw error instanceof _utils__WEBPACK_IMPORTED_MODULE_0__.AppError ? error : new _utils__WEBPACK_IMPORTED_MODULE_0__.AppError(_config_constants__WEBPACK_IMPORTED_MODULE_1__.ERROR_CODES.OCR_FAILED, \"Failed to extract text\");\n        }\n    }\n    // Summarization API\n    async summarizeText(text) {\n        _utils__WEBPACK_IMPORTED_MODULE_0__.logger.info(\"Starting text summarization\", {\n            textLength: text.length\n        }, \"apiClient.summarizeText\");\n        try {\n            const result = await (0,_utils__WEBPACK_IMPORTED_MODULE_0__.retry)(()=>this.request(_config_constants__WEBPACK_IMPORTED_MODULE_1__.API_ENDPOINTS.SUMMARIZE, {\n                    method: \"POST\",\n                    body: JSON.stringify({\n                        text\n                    })\n                }, _config_constants__WEBPACK_IMPORTED_MODULE_1__.APP_CONFIG.apiTimeouts.SUMMARIZE), 2, 1500);\n            _utils__WEBPACK_IMPORTED_MODULE_0__.logger.info(\"Text summarization completed\", {\n                summaryLength: result.summary.length,\n                keyPointsCount: result.keyPoints.length,\n                compressionRatio: result.compressionRatio\n            }, \"apiClient.summarizeText\");\n            return result;\n        } catch (error) {\n            _utils__WEBPACK_IMPORTED_MODULE_0__.logger.error(\"Text summarization failed\", error, \"apiClient.summarizeText\");\n            throw error instanceof _utils__WEBPACK_IMPORTED_MODULE_0__.AppError ? error : new _utils__WEBPACK_IMPORTED_MODULE_0__.AppError(_config_constants__WEBPACK_IMPORTED_MODULE_1__.ERROR_CODES.SUMMARIZATION_FAILED, \"Failed to summarize text\");\n        }\n    }\n    // Analysis API\n    async analyzeText(text) {\n        _utils__WEBPACK_IMPORTED_MODULE_0__.logger.info(\"Starting text analysis\", {\n            textLength: text.length\n        }, \"apiClient.analyzeText\");\n        try {\n            const result = await (0,_utils__WEBPACK_IMPORTED_MODULE_0__.retry)(()=>this.request(_config_constants__WEBPACK_IMPORTED_MODULE_1__.API_ENDPOINTS.ANALYZE, {\n                    method: \"POST\",\n                    body: JSON.stringify({\n                        text\n                    })\n                }, _config_constants__WEBPACK_IMPORTED_MODULE_1__.APP_CONFIG.apiTimeouts.ANALYZE), 2, 1500);\n            _utils__WEBPACK_IMPORTED_MODULE_0__.logger.info(\"Text analysis completed\", {\n                clausesCount: result.clauses.length,\n                riskScore: result.riskScore\n            }, \"apiClient.analyzeText\");\n            return result;\n        } catch (error) {\n            _utils__WEBPACK_IMPORTED_MODULE_0__.logger.error(\"Text analysis failed\", error, \"apiClient.analyzeText\");\n            throw error instanceof _utils__WEBPACK_IMPORTED_MODULE_0__.AppError ? error : new _utils__WEBPACK_IMPORTED_MODULE_0__.AppError(_config_constants__WEBPACK_IMPORTED_MODULE_1__.ERROR_CODES.ANALYSIS_FAILED, \"Failed to analyze text\");\n        }\n    }\n    // Chat API\n    async chatWithDocument(question, context) {\n        _utils__WEBPACK_IMPORTED_MODULE_0__.logger.info(\"Starting chat request\", {\n            questionLength: question.length,\n            contextLength: context.length\n        }, \"apiClient.chatWithDocument\");\n        try {\n            const result = await this.request(_config_constants__WEBPACK_IMPORTED_MODULE_1__.API_ENDPOINTS.CHAT, {\n                method: \"POST\",\n                body: JSON.stringify({\n                    question,\n                    context\n                })\n            }, _config_constants__WEBPACK_IMPORTED_MODULE_1__.APP_CONFIG.apiTimeouts.CHAT);\n            // Transform the response to match ChatResponse interface\n            const chatResponse = {\n                answer: result.answer,\n                confidence: 0.8,\n                sources: [],\n                suggestedQuestions: [] // Could be enhanced to return suggestions\n            };\n            _utils__WEBPACK_IMPORTED_MODULE_0__.logger.info(\"Chat request completed\", {\n                answerLength: chatResponse.answer.length,\n                confidence: chatResponse.confidence\n            }, \"apiClient.chatWithDocument\");\n            return chatResponse;\n        } catch (error) {\n            _utils__WEBPACK_IMPORTED_MODULE_0__.logger.error(\"Chat request failed\", error, \"apiClient.chatWithDocument\");\n            throw error instanceof _utils__WEBPACK_IMPORTED_MODULE_0__.AppError ? error : new _utils__WEBPACK_IMPORTED_MODULE_0__.AppError(_config_constants__WEBPACK_IMPORTED_MODULE_1__.ERROR_CODES.CHAT_FAILED, \"Failed to process chat request\");\n        }\n    }\n    // Visualization API\n    async generateVisualization(text, analysisResults) {\n        _utils__WEBPACK_IMPORTED_MODULE_0__.logger.info(\"Starting visualization generation\", {\n            textLength: text.length\n        }, \"apiClient.generateVisualization\");\n        try {\n            const result = await this.request(_config_constants__WEBPACK_IMPORTED_MODULE_1__.API_ENDPOINTS.VISUALIZE, {\n                method: \"POST\",\n                body: JSON.stringify({\n                    text,\n                    analysisResults\n                })\n            }, _config_constants__WEBPACK_IMPORTED_MODULE_1__.APP_CONFIG.apiTimeouts.VISUALIZE);\n            _utils__WEBPACK_IMPORTED_MODULE_0__.logger.info(\"Visualization generation completed\", {\n                nodesCount: result.flowData.nodes.length,\n                relationshipsCount: result.flowData.relationships.length\n            }, \"apiClient.generateVisualization\");\n            return result.flowData;\n        } catch (error) {\n            _utils__WEBPACK_IMPORTED_MODULE_0__.logger.error(\"Visualization generation failed\", error, \"apiClient.generateVisualization\");\n            throw error instanceof _utils__WEBPACK_IMPORTED_MODULE_0__.AppError ? error : new _utils__WEBPACK_IMPORTED_MODULE_0__.AppError(_config_constants__WEBPACK_IMPORTED_MODULE_1__.ERROR_CODES.ANALYSIS_FAILED, \"Failed to generate visualization\");\n        }\n    }\n    // Health check\n    async healthCheck() {\n        try {\n            const result = await this.request(\"/health\", {\n                method: \"GET\"\n            }, 5000);\n            return {\n                status: result.status || \"ok\",\n                timestamp: new Date()\n            };\n        } catch (error) {\n            _utils__WEBPACK_IMPORTED_MODULE_0__.logger.warn(\"Health check failed\", error, \"apiClient.healthCheck\");\n            return {\n                status: \"error\",\n                timestamp: new Date()\n            };\n        }\n    }\n    constructor(){\n        this.baseURL = \"/api\";\n    }\n}\n// Export singleton instance\nconst apiClient = new APIClient();\n// Export class for testing\n\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUNkN0IsMENBQU1BLENBQUNtRyxJQUFJLENBQUMsdUJBQXVCdEUsT0FBTztZQUMxQyxPQUFPO2dCQUNMRSxRQUFRO2dCQUNSa0UsV0FBVyxJQUFJQztZQUNqQjtRQUNGO0lBQ0Y7O2FBM1BRakYsVUFBVTs7QUE0UHBCO0FBRUEsNEJBQTRCO0FBQ3JCLE1BQU1tRixZQUFZLElBQUkvRixZQUFXO0FBRXhDLDJCQUEyQjtBQUNQIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2xpYi9hcGlDbGllbnQudHM/ZjQ4YyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBBUEkgQ2xpZW50IGZvciBMZWdhbExlbnMgQUlcbmltcG9ydCB0eXBlIHsgQVBJUmVzcG9uc2UsIE9DUlJlc3VsdCwgU3VtbWFyeVJlc3VsdCwgQ2hhdFJlc3BvbnNlLCBGbG93VmlzdWFsaXphdGlvbkRhdGEgfSBmcm9tICcuLi90eXBlcydcbmltcG9ydCB7IEFwcEVycm9yLCBsb2dnZXIsIHJldHJ5IH0gZnJvbSAnLi91dGlscydcbmltcG9ydCB7IEFQSV9FTkRQT0lOVFMsIEVSUk9SX0NPREVTLCBBUFBfQ09ORklHIH0gZnJvbSAnLi4vY29uZmlnL2NvbnN0YW50cydcblxuY2xhc3MgQVBJQ2xpZW50IHtcbiAgcHJpdmF0ZSBiYXNlVVJMID0gJy9hcGknXG4gIFxuICBwcml2YXRlIGFzeW5jIHJlcXVlc3Q8VD4oXG4gICAgZW5kcG9pbnQ6IHN0cmluZyxcbiAgICBvcHRpb25zOiBSZXF1ZXN0SW5pdCA9IHt9LFxuICAgIHRpbWVvdXQ6IG51bWJlciA9IDMwMDAwXG4gICk6IFByb21pc2U8VD4ge1xuICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKClcbiAgICBjb25zdCB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IGNvbnRyb2xsZXIuYWJvcnQoKSwgdGltZW91dClcbiAgICBcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHt0aGlzLmJhc2VVUkx9JHtlbmRwb2ludH1gLCB7XG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIHNpZ25hbDogY29udHJvbGxlci5zaWduYWwsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAuLi4ob3B0aW9ucy5ib2R5IGluc3RhbmNlb2YgRm9ybURhdGEgPyB7fSA6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9KSxcbiAgICAgICAgICAuLi5vcHRpb25zLmhlYWRlcnNcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIFxuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZClcbiAgICAgIFxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBlcnJvclRleHQgPSBhd2FpdCByZXNwb25zZS50ZXh0KClcbiAgICAgICAgbGV0IGVycm9yRGF0YVxuICAgICAgICBcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBlcnJvckRhdGEgPSBKU09OLnBhcnNlKGVycm9yVGV4dClcbiAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgZXJyb3JEYXRhID0geyBlcnJvcjogZXJyb3JUZXh0IH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgdGhyb3cgbmV3IEFwcEVycm9yKFxuICAgICAgICAgIHRoaXMuZ2V0RXJyb3JDb2RlKHJlc3BvbnNlLnN0YXR1cyksXG4gICAgICAgICAgZXJyb3JEYXRhLmVycm9yIHx8IGBIVFRQICR7cmVzcG9uc2Uuc3RhdHVzfTogJHtyZXNwb25zZS5zdGF0dXNUZXh0fWAsXG4gICAgICAgICAgeyBzdGF0dXM6IHJlc3BvbnNlLnN0YXR1cywgcmVzcG9uc2U6IGVycm9yRGF0YSB9XG4gICAgICAgIClcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKVxuICAgICAgXG4gICAgICBpZiAoZGF0YS5lcnJvcikge1xuICAgICAgICB0aHJvdyBuZXcgQXBwRXJyb3IoXG4gICAgICAgICAgRVJST1JfQ09ERVMuQVBJX1RJTUVPVVQsXG4gICAgICAgICAgZGF0YS5lcnJvcixcbiAgICAgICAgICBkYXRhXG4gICAgICAgIClcbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIGRhdGFcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZClcbiAgICAgIFxuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgQXBwRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZXJyb3JcbiAgICAgIH1cbiAgICAgIFxuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgaWYgKGVycm9yLm5hbWUgPT09ICdBYm9ydEVycm9yJykge1xuICAgICAgICAgIHRocm93IG5ldyBBcHBFcnJvcihFUlJPUl9DT0RFUy5BUElfVElNRU9VVCwgJ1JlcXVlc3QgdGltZWQgb3V0JylcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYgKGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoJ2ZldGNoJykpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgQXBwRXJyb3IoRVJST1JfQ09ERVMuTkVUV09SS19FUlJPUiwgJ05ldHdvcmsgZXJyb3Igb2NjdXJyZWQnKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIHRocm93IG5ldyBBcHBFcnJvcihcbiAgICAgICAgRVJST1JfQ09ERVMuTkVUV09SS19FUlJPUixcbiAgICAgICAgJ0FuIHVuZXhwZWN0ZWQgZXJyb3Igb2NjdXJyZWQnLFxuICAgICAgICBlcnJvclxuICAgICAgKVxuICAgIH1cbiAgfVxuICBcbiAgcHJpdmF0ZSBnZXRFcnJvckNvZGUoc3RhdHVzOiBudW1iZXIpOiBzdHJpbmcge1xuICAgIHN3aXRjaCAoc3RhdHVzKSB7XG4gICAgICBjYXNlIDQwMDpcbiAgICAgICAgcmV0dXJuIEVSUk9SX0NPREVTLklOVkFMSURfSU5QVVRcbiAgICAgIGNhc2UgNDA4OlxuICAgICAgICByZXR1cm4gRVJST1JfQ09ERVMuQVBJX1RJTUVPVVRcbiAgICAgIGNhc2UgNDEzOlxuICAgICAgICByZXR1cm4gRVJST1JfQ09ERVMuRklMRV9UT09fTEFSR0VcbiAgICAgIGNhc2UgNDE1OlxuICAgICAgICByZXR1cm4gRVJST1JfQ09ERVMuVU5TVVBQT1JURURfRk9STUFUXG4gICAgICBjYXNlIDQyOTpcbiAgICAgICAgcmV0dXJuIEVSUk9SX0NPREVTLlJBVEVfTElNSVRFRFxuICAgICAgY2FzZSA1MDA6XG4gICAgICBjYXNlIDUwMjpcbiAgICAgIGNhc2UgNTAzOlxuICAgICAgY2FzZSA1MDQ6XG4gICAgICAgIHJldHVybiBFUlJPUl9DT0RFUy5ORVRXT1JLX0VSUk9SXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gRVJST1JfQ09ERVMuTkVUV09SS19FUlJPUlxuICAgIH1cbiAgfVxuICBcbiAgLy8gT0NSIEFQSVxuICBhc3luYyBleHRyYWN0VGV4dChmaWxlOiBGaWxlKTogUHJvbWlzZTxPQ1JSZXN1bHQ+IHtcbiAgICBsb2dnZXIuaW5mbygnU3RhcnRpbmcgT0NSIGV4dHJhY3Rpb24nLCB7IGZpbGVOYW1lOiBmaWxlLm5hbWUsIGZpbGVTaXplOiBmaWxlLnNpemUgfSwgJ2FwaUNsaWVudC5leHRyYWN0VGV4dCcpXG4gICAgXG4gICAgY29uc3QgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKVxuICAgIGZvcm1EYXRhLmFwcGVuZCgnZmlsZScsIGZpbGUpXG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJldHJ5KFxuICAgICAgICAoKSA9PiB0aGlzLnJlcXVlc3Q8T0NSUmVzdWx0PihBUElfRU5EUE9JTlRTLk9DUiwge1xuICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgIGJvZHk6IGZvcm1EYXRhLFxuICAgICAgICAgIGhlYWRlcnM6IHt9IC8vIFJlbW92ZSBDb250ZW50LVR5cGUgdG8gbGV0IGJyb3dzZXIgc2V0IGl0IGZvciBGb3JtRGF0YVxuICAgICAgICB9LCBBUFBfQ09ORklHLmFwaVRpbWVvdXRzLk9DUiksXG4gICAgICAgIDIsIC8vIE1heCAyIHJldHJpZXMgZm9yIE9DUlxuICAgICAgICAyMDAwIC8vIDIgc2Vjb25kIGRlbGF5XG4gICAgICApXG4gICAgICBcbiAgICAgIGxvZ2dlci5pbmZvKCdPQ1IgZXh0cmFjdGlvbiBjb21wbGV0ZWQnLCB7XG4gICAgICAgIHRleHRMZW5ndGg6IHJlc3VsdC50ZXh0Lmxlbmd0aCxcbiAgICAgICAgY29uZmlkZW5jZTogcmVzdWx0LmNvbmZpZGVuY2UsXG4gICAgICAgIG1ldGhvZDogcmVzdWx0Lm1ldGhvZFxuICAgICAgfSwgJ2FwaUNsaWVudC5leHRyYWN0VGV4dCcpXG4gICAgICBcbiAgICAgIHJldHVybiByZXN1bHRcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nZ2VyLmVycm9yKCdPQ1IgZXh0cmFjdGlvbiBmYWlsZWQnLCBlcnJvciwgJ2FwaUNsaWVudC5leHRyYWN0VGV4dCcpXG4gICAgICB0aHJvdyBlcnJvciBpbnN0YW5jZW9mIEFwcEVycm9yID8gZXJyb3IgOiBuZXcgQXBwRXJyb3IoRVJST1JfQ09ERVMuT0NSX0ZBSUxFRCwgJ0ZhaWxlZCB0byBleHRyYWN0IHRleHQnKVxuICAgIH1cbiAgfVxuICBcbiAgLy8gU3VtbWFyaXphdGlvbiBBUElcbiAgYXN5bmMgc3VtbWFyaXplVGV4dCh0ZXh0OiBzdHJpbmcpOiBQcm9taXNlPFN1bW1hcnlSZXN1bHQ+IHtcbiAgICBsb2dnZXIuaW5mbygnU3RhcnRpbmcgdGV4dCBzdW1tYXJpemF0aW9uJywgeyB0ZXh0TGVuZ3RoOiB0ZXh0Lmxlbmd0aCB9LCAnYXBpQ2xpZW50LnN1bW1hcml6ZVRleHQnKVxuICAgIFxuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXRyeShcbiAgICAgICAgKCkgPT4gdGhpcy5yZXF1ZXN0PFN1bW1hcnlSZXN1bHQ+KEFQSV9FTkRQT0lOVFMuU1VNTUFSSVpFLCB7XG4gICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyB0ZXh0IH0pXG4gICAgICAgIH0sIEFQUF9DT05GSUcuYXBpVGltZW91dHMuU1VNTUFSSVpFKSxcbiAgICAgICAgMixcbiAgICAgICAgMTUwMFxuICAgICAgKVxuICAgICAgXG4gICAgICBsb2dnZXIuaW5mbygnVGV4dCBzdW1tYXJpemF0aW9uIGNvbXBsZXRlZCcsIHtcbiAgICAgICAgc3VtbWFyeUxlbmd0aDogcmVzdWx0LnN1bW1hcnkubGVuZ3RoLFxuICAgICAgICBrZXlQb2ludHNDb3VudDogcmVzdWx0LmtleVBvaW50cy5sZW5ndGgsXG4gICAgICAgIGNvbXByZXNzaW9uUmF0aW86IHJlc3VsdC5jb21wcmVzc2lvblJhdGlvXG4gICAgICB9LCAnYXBpQ2xpZW50LnN1bW1hcml6ZVRleHQnKVxuICAgICAgXG4gICAgICByZXR1cm4gcmVzdWx0XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZ2dlci5lcnJvcignVGV4dCBzdW1tYXJpemF0aW9uIGZhaWxlZCcsIGVycm9yLCAnYXBpQ2xpZW50LnN1bW1hcml6ZVRleHQnKVxuICAgICAgdGhyb3cgZXJyb3IgaW5zdGFuY2VvZiBBcHBFcnJvciA/IGVycm9yIDogbmV3IEFwcEVycm9yKEVSUk9SX0NPREVTLlNVTU1BUklaQVRJT05fRkFJTEVELCAnRmFpbGVkIHRvIHN1bW1hcml6ZSB0ZXh0JylcbiAgICB9XG4gIH1cbiAgXG4gIC8vIEFuYWx5c2lzIEFQSVxuICBhc3luYyBhbmFseXplVGV4dCh0ZXh0OiBzdHJpbmcpOiBQcm9taXNlPHsgY2xhdXNlczogYW55W10sIHJpc2tTY29yZTogbnVtYmVyLCBzdW1tYXJ5OiBzdHJpbmcgfT4ge1xuICAgIGxvZ2dlci5pbmZvKCdTdGFydGluZyB0ZXh0IGFuYWx5c2lzJywgeyB0ZXh0TGVuZ3RoOiB0ZXh0Lmxlbmd0aCB9LCAnYXBpQ2xpZW50LmFuYWx5emVUZXh0JylcbiAgICBcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmV0cnkoXG4gICAgICAgICgpID0+IHRoaXMucmVxdWVzdDx7IGNsYXVzZXM6IGFueVtdLCByaXNrU2NvcmU6IG51bWJlciwgc3VtbWFyeTogc3RyaW5nIH0+KEFQSV9FTkRQT0lOVFMuQU5BTFlaRSwge1xuICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgdGV4dCB9KVxuICAgICAgICB9LCBBUFBfQ09ORklHLmFwaVRpbWVvdXRzLkFOQUxZWkUpLFxuICAgICAgICAyLFxuICAgICAgICAxNTAwXG4gICAgICApXG4gICAgICBcbiAgICAgIGxvZ2dlci5pbmZvKCdUZXh0IGFuYWx5c2lzIGNvbXBsZXRlZCcsIHtcbiAgICAgICAgY2xhdXNlc0NvdW50OiByZXN1bHQuY2xhdXNlcy5sZW5ndGgsXG4gICAgICAgIHJpc2tTY29yZTogcmVzdWx0LnJpc2tTY29yZVxuICAgICAgfSwgJ2FwaUNsaWVudC5hbmFseXplVGV4dCcpXG4gICAgICBcbiAgICAgIHJldHVybiByZXN1bHRcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nZ2VyLmVycm9yKCdUZXh0IGFuYWx5c2lzIGZhaWxlZCcsIGVycm9yLCAnYXBpQ2xpZW50LmFuYWx5emVUZXh0JylcbiAgICAgIHRocm93IGVycm9yIGluc3RhbmNlb2YgQXBwRXJyb3IgPyBlcnJvciA6IG5ldyBBcHBFcnJvcihFUlJPUl9DT0RFUy5BTkFMWVNJU19GQUlMRUQsICdGYWlsZWQgdG8gYW5hbHl6ZSB0ZXh0JylcbiAgICB9XG4gIH1cbiAgXG4gIC8vIENoYXQgQVBJXG4gIGFzeW5jIGNoYXRXaXRoRG9jdW1lbnQocXVlc3Rpb246IHN0cmluZywgY29udGV4dDogc3RyaW5nKTogUHJvbWlzZTxDaGF0UmVzcG9uc2U+IHtcbiAgICBsb2dnZXIuaW5mbygnU3RhcnRpbmcgY2hhdCByZXF1ZXN0JywgeyBxdWVzdGlvbkxlbmd0aDogcXVlc3Rpb24ubGVuZ3RoLCBjb250ZXh0TGVuZ3RoOiBjb250ZXh0Lmxlbmd0aCB9LCAnYXBpQ2xpZW50LmNoYXRXaXRoRG9jdW1lbnQnKVxuICAgIFxuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLnJlcXVlc3Q8eyBhbnN3ZXI6IHN0cmluZyB9PihBUElfRU5EUE9JTlRTLkNIQVQsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgcXVlc3Rpb24sIGNvbnRleHQgfSlcbiAgICAgIH0sIEFQUF9DT05GSUcuYXBpVGltZW91dHMuQ0hBVClcbiAgICAgIFxuICAgICAgLy8gVHJhbnNmb3JtIHRoZSByZXNwb25zZSB0byBtYXRjaCBDaGF0UmVzcG9uc2UgaW50ZXJmYWNlXG4gICAgICBjb25zdCBjaGF0UmVzcG9uc2U6IENoYXRSZXNwb25zZSA9IHtcbiAgICAgICAgYW5zd2VyOiByZXN1bHQuYW5zd2VyLFxuICAgICAgICBjb25maWRlbmNlOiAwLjgsIC8vIERlZmF1bHQgY29uZmlkZW5jZSBzaW5jZSBBUEkgZG9lc24ndCByZXR1cm4gaXRcbiAgICAgICAgc291cmNlczogW10sIC8vIENvdWxkIGJlIGVuaGFuY2VkIHRvIHJldHVybiBzb3VyY2VzXG4gICAgICAgIHN1Z2dlc3RlZFF1ZXN0aW9uczogW10gLy8gQ291bGQgYmUgZW5oYW5jZWQgdG8gcmV0dXJuIHN1Z2dlc3Rpb25zXG4gICAgICB9XG4gICAgICBcbiAgICAgIGxvZ2dlci5pbmZvKCdDaGF0IHJlcXVlc3QgY29tcGxldGVkJywge1xuICAgICAgICBhbnN3ZXJMZW5ndGg6IGNoYXRSZXNwb25zZS5hbnN3ZXIubGVuZ3RoLFxuICAgICAgICBjb25maWRlbmNlOiBjaGF0UmVzcG9uc2UuY29uZmlkZW5jZVxuICAgICAgfSwgJ2FwaUNsaWVudC5jaGF0V2l0aERvY3VtZW50JylcbiAgICAgIFxuICAgICAgcmV0dXJuIGNoYXRSZXNwb25zZVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2dnZXIuZXJyb3IoJ0NoYXQgcmVxdWVzdCBmYWlsZWQnLCBlcnJvciwgJ2FwaUNsaWVudC5jaGF0V2l0aERvY3VtZW50JylcbiAgICAgIHRocm93IGVycm9yIGluc3RhbmNlb2YgQXBwRXJyb3IgPyBlcnJvciA6IG5ldyBBcHBFcnJvcihFUlJPUl9DT0RFUy5DSEFUX0ZBSUxFRCwgJ0ZhaWxlZCB0byBwcm9jZXNzIGNoYXQgcmVxdWVzdCcpXG4gICAgfVxuICB9XG4gIFxuICAvLyBWaXN1YWxpemF0aW9uIEFQSVxuICBhc3luYyBnZW5lcmF0ZVZpc3VhbGl6YXRpb24odGV4dDogc3RyaW5nLCBhbmFseXNpc1Jlc3VsdHM/OiBhbnkpOiBQcm9taXNlPEZsb3dWaXN1YWxpemF0aW9uRGF0YT4ge1xuICAgIGxvZ2dlci5pbmZvKCdTdGFydGluZyB2aXN1YWxpemF0aW9uIGdlbmVyYXRpb24nLCB7IHRleHRMZW5ndGg6IHRleHQubGVuZ3RoIH0sICdhcGlDbGllbnQuZ2VuZXJhdGVWaXN1YWxpemF0aW9uJylcbiAgICBcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5yZXF1ZXN0PHsgZmxvd0RhdGE6IEZsb3dWaXN1YWxpemF0aW9uRGF0YSB9PihBUElfRU5EUE9JTlRTLlZJU1VBTElaRSwge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyB0ZXh0LCBhbmFseXNpc1Jlc3VsdHMgfSlcbiAgICAgIH0sIEFQUF9DT05GSUcuYXBpVGltZW91dHMuVklTVUFMSVpFKVxuICAgICAgXG4gICAgICBsb2dnZXIuaW5mbygnVmlzdWFsaXphdGlvbiBnZW5lcmF0aW9uIGNvbXBsZXRlZCcsIHtcbiAgICAgICAgbm9kZXNDb3VudDogcmVzdWx0LmZsb3dEYXRhLm5vZGVzLmxlbmd0aCxcbiAgICAgICAgcmVsYXRpb25zaGlwc0NvdW50OiByZXN1bHQuZmxvd0RhdGEucmVsYXRpb25zaGlwcy5sZW5ndGhcbiAgICAgIH0sICdhcGlDbGllbnQuZ2VuZXJhdGVWaXN1YWxpemF0aW9uJylcbiAgICAgIFxuICAgICAgcmV0dXJuIHJlc3VsdC5mbG93RGF0YVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2dnZXIuZXJyb3IoJ1Zpc3VhbGl6YXRpb24gZ2VuZXJhdGlvbiBmYWlsZWQnLCBlcnJvciwgJ2FwaUNsaWVudC5nZW5lcmF0ZVZpc3VhbGl6YXRpb24nKVxuICAgICAgdGhyb3cgZXJyb3IgaW5zdGFuY2VvZiBBcHBFcnJvciA/IGVycm9yIDogbmV3IEFwcEVycm9yKEVSUk9SX0NPREVTLkFOQUxZU0lTX0ZBSUxFRCwgJ0ZhaWxlZCB0byBnZW5lcmF0ZSB2aXN1YWxpemF0aW9uJylcbiAgICB9XG4gIH1cbiAgXG4gIC8vIEhlYWx0aCBjaGVja1xuICBhc3luYyBoZWFsdGhDaGVjaygpOiBQcm9taXNlPHsgc3RhdHVzOiBzdHJpbmc7IHRpbWVzdGFtcDogRGF0ZSB9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMucmVxdWVzdDx7IHN0YXR1czogc3RyaW5nIH0+KCcvaGVhbHRoJywge1xuICAgICAgICBtZXRob2Q6ICdHRVQnXG4gICAgICB9LCA1MDAwKVxuICAgICAgXG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdGF0dXM6IHJlc3VsdC5zdGF0dXMgfHwgJ29rJyxcbiAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpXG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZ2dlci53YXJuKCdIZWFsdGggY2hlY2sgZmFpbGVkJywgZXJyb3IsICdhcGlDbGllbnQuaGVhbHRoQ2hlY2snKVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3RhdHVzOiAnZXJyb3InLFxuICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKClcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLy8gRXhwb3J0IHNpbmdsZXRvbiBpbnN0YW5jZVxuZXhwb3J0IGNvbnN0IGFwaUNsaWVudCA9IG5ldyBBUElDbGllbnQoKVxuXG4vLyBFeHBvcnQgY2xhc3MgZm9yIHRlc3RpbmdcbmV4cG9ydCB7IEFQSUNsaWVudCB9Il0sIm5hbWVzIjpbIkFwcEVycm9yIiwibG9nZ2VyIiwicmV0cnkiLCJBUElfRU5EUE9JTlRTIiwiRVJST1JfQ09ERVMiLCJBUFBfQ09ORklHIiwiQVBJQ2xpZW50IiwicmVxdWVzdCIsImVuZHBvaW50Iiwib3B0aW9ucyIsInRpbWVvdXQiLCJjb250cm9sbGVyIiwiQWJvcnRDb250cm9sbGVyIiwidGltZW91dElkIiwic2V0VGltZW91dCIsImFib3J0IiwicmVzcG9uc2UiLCJmZXRjaCIsImJhc2VVUkwiLCJzaWduYWwiLCJoZWFkZXJzIiwiYm9keSIsIkZvcm1EYXRhIiwiY2xlYXJUaW1lb3V0Iiwib2siLCJlcnJvclRleHQiLCJ0ZXh0IiwiZXJyb3JEYXRhIiwiSlNPTiIsInBhcnNlIiwiZXJyb3IiLCJnZXRFcnJvckNvZGUiLCJzdGF0dXMiLCJzdGF0dXNUZXh0IiwiZGF0YSIsImpzb24iLCJBUElfVElNRU9VVCIsIkVycm9yIiwibmFtZSIsIm1lc3NhZ2UiLCJpbmNsdWRlcyIsIk5FVFdPUktfRVJST1IiLCJJTlZBTElEX0lOUFVUIiwiRklMRV9UT09fTEFSR0UiLCJVTlNVUFBPUlRFRF9GT1JNQVQiLCJSQVRFX0xJTUlURUQiLCJleHRyYWN0VGV4dCIsImZpbGUiLCJpbmZvIiwiZmlsZU5hbWUiLCJmaWxlU2l6ZSIsInNpemUiLCJmb3JtRGF0YSIsImFwcGVuZCIsInJlc3VsdCIsIk9DUiIsIm1ldGhvZCIsImFwaVRpbWVvdXRzIiwidGV4dExlbmd0aCIsImxlbmd0aCIsImNvbmZpZGVuY2UiLCJPQ1JfRkFJTEVEIiwic3VtbWFyaXplVGV4dCIsIlNVTU1BUklaRSIsInN0cmluZ2lmeSIsInN1bW1hcnlMZW5ndGgiLCJzdW1tYXJ5Iiwia2V5UG9pbnRzQ291bnQiLCJrZXlQb2ludHMiLCJjb21wcmVzc2lvblJhdGlvIiwiU1VNTUFSSVpBVElPTl9GQUlMRUQiLCJhbmFseXplVGV4dCIsIkFOQUxZWkUiLCJjbGF1c2VzQ291bnQiLCJjbGF1c2VzIiwicmlza1Njb3JlIiwiQU5BTFlTSVNfRkFJTEVEIiwiY2hhdFdpdGhEb2N1bWVudCIsInF1ZXN0aW9uIiwiY29udGV4dCIsInF1ZXN0aW9uTGVuZ3RoIiwiY29udGV4dExlbmd0aCIsIkNIQVQiLCJjaGF0UmVzcG9uc2UiLCJhbnN3ZXIiLCJzb3VyY2VzIiwic3VnZ2VzdGVkUXVlc3Rpb25zIiwiYW5zd2VyTGVuZ3RoIiwiQ0hBVF9GQUlMRUQiLCJnZW5lcmF0ZVZpc3VhbGl6YXRpb24iLCJhbmFseXNpc1Jlc3VsdHMiLCJWSVNVQUxJWkUiLCJub2Rlc0NvdW50IiwiZmxvd0RhdGEiLCJub2RlcyIsInJlbGF0aW9uc2hpcHNDb3VudCIsInJlbGF0aW9uc2hpcHMiLCJoZWFsdGhDaGVjayIsInRpbWVzdGFtcCIsIkRhdGUiLCJ3YXJuIiwiYXBpQ2xpZW50Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./lib/apiClient.ts\n"));

/***/ })

});