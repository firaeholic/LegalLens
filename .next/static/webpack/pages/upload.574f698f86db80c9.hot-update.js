"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/upload",{

/***/ "./lib/validation.ts":
/*!***************************!*\
  !*** ./lib/validation.ts ***!
  \***************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createValidationSchema: function() { return /* binding */ createValidationSchema; },\n/* harmony export */   sanitizeText: function() { return /* binding */ sanitizeText; },\n/* harmony export */   validateApiRequest: function() { return /* binding */ validateApiRequest; },\n/* harmony export */   validateBatch: function() { return /* binding */ validateBatch; },\n/* harmony export */   validateClauseType: function() { return /* binding */ validateClauseType; },\n/* harmony export */   validateConfidence: function() { return /* binding */ validateConfidence; },\n/* harmony export */   validateEmail: function() { return /* binding */ validateEmail; },\n/* harmony export */   validateFile: function() { return /* binding */ validateFile; },\n/* harmony export */   validateJson: function() { return /* binding */ validateJson; },\n/* harmony export */   validateRiskLevel: function() { return /* binding */ validateRiskLevel; },\n/* harmony export */   validateText: function() { return /* binding */ validateText; },\n/* harmony export */   validateUrl: function() { return /* binding */ validateUrl; }\n/* harmony export */ });\n/* harmony import */ var _config_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../config/constants */ \"./config/constants.ts\");\n// Input validation utilities\n\n// File validation\nfunction validateFile(file) {\n    const warnings = [];\n    // Check file size\n    if (file.size > _config_constants__WEBPACK_IMPORTED_MODULE_0__.APP_CONFIG.maxFileSize) {\n        return {\n            isValid: false,\n            error: \"File size (\".concat(formatFileSize(file.size), \") exceeds maximum allowed size (\").concat(formatFileSize(_config_constants__WEBPACK_IMPORTED_MODULE_0__.APP_CONFIG.maxFileSize), \")\")\n        };\n    }\n    // Check file type with comprehensive validation\n    const fileName = file.name.toLowerCase();\n    const fileType = file.type.toLowerCase();\n    // Define comprehensive MIME type mappings\n    const validMimeTypes = new Set([\n        \"application/pdf\",\n        \"image/png\",\n        \"image/jpeg\",\n        \"image/jpg\",\n        \"image/webp\"\n    ]);\n    // Define valid file extensions\n    const validExtensions = new Set([\n        \".pdf\",\n        \".png\",\n        \".jpg\",\n        \".jpeg\",\n        \".webp\"\n    ]);\n    // Check by MIME type first\n    const isValidMimeType = validMimeTypes.has(fileType);\n    // Check by file extension as fallback\n    const hasValidExtension = Array.from(validExtensions).some((ext)=>fileName.endsWith(ext));\n    // Additional check for common PNG variations\n    const isPngFile = fileType.includes(\"png\") || fileName.endsWith(\".png\");\n    const isJpegFile = fileType.includes(\"jpeg\") || fileType.includes(\"jpg\") || fileName.endsWith(\".jpg\") || fileName.endsWith(\".jpeg\");\n    const isPdfFile = fileType.includes(\"pdf\") || fileName.endsWith(\".pdf\");\n    const isWebpFile = fileType.includes(\"webp\") || fileName.endsWith(\".webp\");\n    const isValidType = isValidMimeType || hasValidExtension || isPngFile || isJpegFile || isPdfFile || isWebpFile;\n    if (!isValidType) {\n        return {\n            isValid: false,\n            error: 'File type \"'.concat(file.type || \"unknown\", '\" is not supported. Supported formats: ').concat(_config_constants__WEBPACK_IMPORTED_MODULE_0__.APP_CONFIG.supportedFormats.join(\", \"))\n        };\n    }\n    // Check file name\n    if (file.name.length > 255) {\n        warnings.push(\"File name is very long and may cause issues\");\n    }\n    // Check for potentially problematic characters\n    const problematicChars = /[<>:\"|?*\\x00-\\x1f]/;\n    if (problematicChars.test(file.name)) {\n        warnings.push(\"File name contains special characters that may cause issues\");\n    }\n    // Warn about very small files\n    if (file.size < 100) {\n        warnings.push(\"File is very small and may not contain meaningful content\");\n    }\n    return {\n        isValid: true,\n        warnings: warnings.length > 0 ? warnings : undefined\n    };\n}\n// Text validation\nfunction validateText(text) {\n    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    const { minLength = 1, maxLength = 1000000, required = true, allowEmpty = false } = options;\n    if (required && !text) {\n        return {\n            isValid: false,\n            error: \"Text is required\"\n        };\n    }\n    if (!allowEmpty && text.trim().length === 0) {\n        return {\n            isValid: false,\n            error: \"Text cannot be empty\"\n        };\n    }\n    if (text.length < minLength) {\n        return {\n            isValid: false,\n            error: \"Text must be at least \".concat(minLength, \" characters long\")\n        };\n    }\n    if (text.length > maxLength) {\n        return {\n            isValid: false,\n            error: \"Text must not exceed \".concat(maxLength, \" characters\")\n        };\n    }\n    const warnings = [];\n    // Check for suspicious content\n    if (text.includes(\"<script>\") || text.includes(\"javascript:\")) {\n        warnings.push(\"Text contains potentially unsafe content\");\n    }\n    // Check for very repetitive content\n    const words = text.split(/\\s+/);\n    const uniqueWords = new Set(words);\n    if (words.length > 100 && uniqueWords.size / words.length < 0.1) {\n        warnings.push(\"Text appears to be very repetitive\");\n    }\n    return {\n        isValid: true,\n        warnings: warnings.length > 0 ? warnings : undefined\n    };\n}\n// API request validation\nfunction validateApiRequest(data, schema) {\n    const { requiredFields, optionalFields = [], maxSize = 10 * 1024 * 1024 } = schema;\n    if (!data || typeof data !== \"object\") {\n        return {\n            isValid: false,\n            error: \"Request data must be an object\"\n        };\n    }\n    // Check required fields\n    for (const field of requiredFields){\n        if (!(field in data) || data[field] === undefined || data[field] === null) {\n            return {\n                isValid: false,\n                error: 'Required field \"'.concat(field, '\" is missing')\n            };\n        }\n    }\n    // Check for unexpected fields\n    const allowedFields = [\n        ...requiredFields,\n        ...optionalFields\n    ];\n    const unexpectedFields = Object.keys(data).filter((key)=>!allowedFields.includes(key));\n    if (unexpectedFields.length > 0) {\n        return {\n            isValid: false,\n            error: \"Unexpected fields: \".concat(unexpectedFields.join(\", \"))\n        };\n    }\n    // Check data size\n    const dataSize = JSON.stringify(data).length;\n    if (dataSize > maxSize) {\n        return {\n            isValid: false,\n            error: \"Request data size (\".concat(formatFileSize(dataSize), \") exceeds maximum allowed size (\").concat(formatFileSize(maxSize), \")\")\n        };\n    }\n    return {\n        isValid: true\n    };\n}\n// Sanitize text input\nfunction sanitizeText(text) {\n    if (!text) return \"\";\n    return text// Remove null bytes\n    .replace(/\\0/g, \"\")// Normalize whitespace\n    .replace(/\\s+/g, \" \")// Trim\n    .trim()// Remove potentially dangerous HTML/JS\n    .replace(/<script[^>]*>[\\s\\S]*?<\\/script>/gi, \"\").replace(/javascript:/gi, \"\").replace(/on\\w+\\s*=/gi, \"\");\n}\n// Validate risk level\nfunction validateRiskLevel(riskLevel) {\n    return [\n        \"low\",\n        \"medium\",\n        \"high\"\n    ].includes(riskLevel);\n}\n// Validate clause type\nfunction validateClauseType(clauseType) {\n    return [\n        \"termination\",\n        \"payment\",\n        \"liability\",\n        \"confidentiality\",\n        \"intellectual_property\",\n        \"dispute_resolution\",\n        \"force_majeure\",\n        \"governing_law\",\n        \"amendment\",\n        \"assignment\",\n        \"warranty\",\n        \"indemnification\",\n        \"compliance\",\n        \"data_protection\",\n        \"other\"\n    ].includes(clauseType);\n}\n// Validate email format\nfunction validateEmail(email) {\n    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n    if (!email) {\n        return {\n            isValid: false,\n            error: \"Email is required\"\n        };\n    }\n    if (!emailRegex.test(email)) {\n        return {\n            isValid: false,\n            error: \"Invalid email format\"\n        };\n    }\n    if (email.length > 254) {\n        return {\n            isValid: false,\n            error: \"Email is too long\"\n        };\n    }\n    return {\n        isValid: true\n    };\n}\n// Validate URL format\nfunction validateUrl(url) {\n    if (!url) {\n        return {\n            isValid: false,\n            error: \"URL is required\"\n        };\n    }\n    try {\n        const urlObj = new URL(url);\n        // Check protocol\n        if (![\n            \"http:\",\n            \"https:\"\n        ].includes(urlObj.protocol)) {\n            return {\n                isValid: false,\n                error: \"URL must use HTTP or HTTPS protocol\"\n            };\n        }\n        return {\n            isValid: true\n        };\n    } catch (e) {\n        return {\n            isValid: false,\n            error: \"Invalid URL format\"\n        };\n    }\n}\n// Validate JSON string\nfunction validateJson(jsonString) {\n    if (!jsonString) {\n        return {\n            isValid: false,\n            error: \"JSON string is required\"\n        };\n    }\n    try {\n        JSON.parse(jsonString);\n        return {\n            isValid: true\n        };\n    } catch (error) {\n        return {\n            isValid: false,\n            error: \"Invalid JSON: \".concat(error instanceof Error ? error.message : \"Unknown error\")\n        };\n    }\n}\n// Validate confidence score\nfunction validateConfidence(confidence) {\n    if (typeof confidence !== \"number\") {\n        return {\n            isValid: false,\n            error: \"Confidence must be a number\"\n        };\n    }\n    if (confidence < 0 || confidence > 1) {\n        return {\n            isValid: false,\n            error: \"Confidence must be between 0 and 1\"\n        };\n    }\n    return {\n        isValid: true\n    };\n}\n// Helper function to format file size\nfunction formatFileSize(bytes) {\n    if (bytes === 0) return \"0 Bytes\";\n    const k = 1024;\n    const sizes = [\n        \"Bytes\",\n        \"KB\",\n        \"MB\",\n        \"GB\"\n    ];\n    const i = Math.floor(Math.log(bytes) / Math.log(k));\n    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + \" \" + sizes[i];\n}\n// Batch validation for multiple inputs\nfunction validateBatch(validations) {\n    const errors = [];\n    const warnings = [];\n    for (const validate of validations){\n        const result = validate();\n        if (!result.isValid && result.error) {\n            errors.push(result.error);\n        }\n        if (result.warnings) {\n            warnings.push(...result.warnings);\n        }\n    }\n    return {\n        isValid: errors.length === 0,\n        error: errors.length > 0 ? errors.join(\"; \") : undefined,\n        warnings: warnings.length > 0 ? warnings : undefined\n    };\n}\n// Create validation schema\nfunction createValidationSchema(validators) {\n    return (data)=>{\n        const errors = [];\n        const warnings = [];\n        for (const [key, validator] of Object.entries(validators)){\n            if (validator && key in data) {\n                const result = validator(data[key]);\n                if (!result.isValid && result.error) {\n                    errors.push(\"\".concat(key, \": \").concat(result.error));\n                }\n                if (result.warnings) {\n                    warnings.push(...result.warnings.map((w)=>\"\".concat(key, \": \").concat(w)));\n                }\n            }\n        }\n        return {\n            isValid: errors.length === 0,\n            error: errors.length > 0 ? errors.join(\"; \") : undefined,\n            warnings: warnings.length > 0 ? warnings : undefined\n        };\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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cEcsU0FBUzRGLE9BQU9qRSxNQUFNLEtBQUs7WUFDM0IxQixPQUFPMkYsT0FBT2pFLE1BQU0sR0FBRyxJQUFJaUUsT0FBT2xFLElBQUksQ0FBQyxRQUFRSztZQUMvQ2xDLFVBQVVBLFNBQVM4QixNQUFNLEdBQUcsSUFBSTlCLFdBQVdrQztRQUM3QztJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbGliL3ZhbGlkYXRpb24udHM/NTBhYyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBJbnB1dCB2YWxpZGF0aW9uIHV0aWxpdGllc1xuaW1wb3J0IHsgQVBQX0NPTkZJRyB9IGZyb20gJy4uL2NvbmZpZy9jb25zdGFudHMnXG5pbXBvcnQgdHlwZSB7IFJpc2tMZXZlbCwgQ2xhdXNlVHlwZSB9IGZyb20gJy4uL3R5cGVzJ1xuXG4vLyBWYWxpZGF0aW9uIHJlc3VsdCBpbnRlcmZhY2VcbmV4cG9ydCBpbnRlcmZhY2UgVmFsaWRhdGlvblJlc3VsdCB7XG4gIGlzVmFsaWQ6IGJvb2xlYW5cbiAgZXJyb3I/OiBzdHJpbmdcbiAgd2FybmluZ3M/OiBzdHJpbmdbXVxufVxuXG4vLyBGaWxlIHZhbGlkYXRpb25cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUZpbGUoZmlsZTogRmlsZSk6IFZhbGlkYXRpb25SZXN1bHQge1xuICBjb25zdCB3YXJuaW5nczogc3RyaW5nW10gPSBbXVxuXG4gIC8vIENoZWNrIGZpbGUgc2l6ZVxuICBpZiAoZmlsZS5zaXplID4gQVBQX0NPTkZJRy5tYXhGaWxlU2l6ZSkge1xuICAgIHJldHVybiB7XG4gICAgICBpc1ZhbGlkOiBmYWxzZSxcbiAgICAgIGVycm9yOiBgRmlsZSBzaXplICgke2Zvcm1hdEZpbGVTaXplKGZpbGUuc2l6ZSl9KSBleGNlZWRzIG1heGltdW0gYWxsb3dlZCBzaXplICgke2Zvcm1hdEZpbGVTaXplKEFQUF9DT05GSUcubWF4RmlsZVNpemUpfSlgXG4gICAgfVxuICB9XG5cbiAgLy8gQ2hlY2sgZmlsZSB0eXBlIHdpdGggY29tcHJlaGVuc2l2ZSB2YWxpZGF0aW9uXG4gIGNvbnN0IGZpbGVOYW1lID0gZmlsZS5uYW1lLnRvTG93ZXJDYXNlKClcbiAgY29uc3QgZmlsZVR5cGUgPSBmaWxlLnR5cGUudG9Mb3dlckNhc2UoKVxuICBcbiAgLy8gRGVmaW5lIGNvbXByZWhlbnNpdmUgTUlNRSB0eXBlIG1hcHBpbmdzXG4gIGNvbnN0IHZhbGlkTWltZVR5cGVzID0gbmV3IFNldChbXG4gICAgJ2FwcGxpY2F0aW9uL3BkZicsXG4gICAgJ2ltYWdlL3BuZycsXG4gICAgJ2ltYWdlL2pwZWcnLFxuICAgICdpbWFnZS9qcGcnLFxuICAgICdpbWFnZS93ZWJwJ1xuICBdKVxuICBcbiAgLy8gRGVmaW5lIHZhbGlkIGZpbGUgZXh0ZW5zaW9uc1xuICBjb25zdCB2YWxpZEV4dGVuc2lvbnMgPSBuZXcgU2V0KFsnLnBkZicsICcucG5nJywgJy5qcGcnLCAnLmpwZWcnLCAnLndlYnAnXSlcbiAgXG4gIC8vIENoZWNrIGJ5IE1JTUUgdHlwZSBmaXJzdFxuICBjb25zdCBpc1ZhbGlkTWltZVR5cGUgPSB2YWxpZE1pbWVUeXBlcy5oYXMoZmlsZVR5cGUpXG4gIFxuICAvLyBDaGVjayBieSBmaWxlIGV4dGVuc2lvbiBhcyBmYWxsYmFja1xuICBjb25zdCBoYXNWYWxpZEV4dGVuc2lvbiA9IEFycmF5LmZyb20odmFsaWRFeHRlbnNpb25zKS5zb21lKGV4dCA9PiBmaWxlTmFtZS5lbmRzV2l0aChleHQpKVxuICBcbiAgLy8gQWRkaXRpb25hbCBjaGVjayBmb3IgY29tbW9uIFBORyB2YXJpYXRpb25zXG4gIGNvbnN0IGlzUG5nRmlsZSA9IGZpbGVUeXBlLmluY2x1ZGVzKCdwbmcnKSB8fCBmaWxlTmFtZS5lbmRzV2l0aCgnLnBuZycpXG4gIGNvbnN0IGlzSnBlZ0ZpbGUgPSAoZmlsZVR5cGUuaW5jbHVkZXMoJ2pwZWcnKSB8fCBmaWxlVHlwZS5pbmNsdWRlcygnanBnJykpIHx8IFxuICAgICAgICAgICAgICAgICAgICAoZmlsZU5hbWUuZW5kc1dpdGgoJy5qcGcnKSB8fCBmaWxlTmFtZS5lbmRzV2l0aCgnLmpwZWcnKSlcbiAgY29uc3QgaXNQZGZGaWxlID0gZmlsZVR5cGUuaW5jbHVkZXMoJ3BkZicpIHx8IGZpbGVOYW1lLmVuZHNXaXRoKCcucGRmJylcbiAgY29uc3QgaXNXZWJwRmlsZSA9IGZpbGVUeXBlLmluY2x1ZGVzKCd3ZWJwJykgfHwgZmlsZU5hbWUuZW5kc1dpdGgoJy53ZWJwJylcbiAgXG4gIGNvbnN0IGlzVmFsaWRUeXBlID0gaXNWYWxpZE1pbWVUeXBlIHx8IGhhc1ZhbGlkRXh0ZW5zaW9uIHx8IGlzUG5nRmlsZSB8fCBpc0pwZWdGaWxlIHx8IGlzUGRmRmlsZSB8fCBpc1dlYnBGaWxlXG5cbiAgaWYgKCFpc1ZhbGlkVHlwZSkge1xuICAgIHJldHVybiB7XG4gICAgICBpc1ZhbGlkOiBmYWxzZSxcbiAgICAgIGVycm9yOiBgRmlsZSB0eXBlIFwiJHtmaWxlLnR5cGUgfHwgJ3Vua25vd24nfVwiIGlzIG5vdCBzdXBwb3J0ZWQuIFN1cHBvcnRlZCBmb3JtYXRzOiAke0FQUF9DT05GSUcuc3VwcG9ydGVkRm9ybWF0cy5qb2luKCcsICcpfWBcbiAgICB9XG4gIH1cblxuICAvLyBDaGVjayBmaWxlIG5hbWVcbiAgaWYgKGZpbGUubmFtZS5sZW5ndGggPiAyNTUpIHtcbiAgICB3YXJuaW5ncy5wdXNoKCdGaWxlIG5hbWUgaXMgdmVyeSBsb25nIGFuZCBtYXkgY2F1c2UgaXNzdWVzJylcbiAgfVxuXG4gIC8vIENoZWNrIGZvciBwb3RlbnRpYWxseSBwcm9ibGVtYXRpYyBjaGFyYWN0ZXJzXG4gIGNvbnN0IHByb2JsZW1hdGljQ2hhcnMgPSAvWzw+OlwifD8qXFx4MDAtXFx4MWZdL1xuICBpZiAocHJvYmxlbWF0aWNDaGFycy50ZXN0KGZpbGUubmFtZSkpIHtcbiAgICB3YXJuaW5ncy5wdXNoKCdGaWxlIG5hbWUgY29udGFpbnMgc3BlY2lhbCBjaGFyYWN0ZXJzIHRoYXQgbWF5IGNhdXNlIGlzc3VlcycpXG4gIH1cblxuICAvLyBXYXJuIGFib3V0IHZlcnkgc21hbGwgZmlsZXNcbiAgaWYgKGZpbGUuc2l6ZSA8IDEwMCkge1xuICAgIHdhcm5pbmdzLnB1c2goJ0ZpbGUgaXMgdmVyeSBzbWFsbCBhbmQgbWF5IG5vdCBjb250YWluIG1lYW5pbmdmdWwgY29udGVudCcpXG4gIH1cblxuICByZXR1cm4ge1xuICAgIGlzVmFsaWQ6IHRydWUsXG4gICAgd2FybmluZ3M6IHdhcm5pbmdzLmxlbmd0aCA+IDAgPyB3YXJuaW5ncyA6IHVuZGVmaW5lZFxuICB9XG59XG5cbi8vIFRleHQgdmFsaWRhdGlvblxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlVGV4dCh0ZXh0OiBzdHJpbmcsIG9wdGlvbnM6IHtcbiAgbWluTGVuZ3RoPzogbnVtYmVyXG4gIG1heExlbmd0aD86IG51bWJlclxuICByZXF1aXJlZD86IGJvb2xlYW5cbiAgYWxsb3dFbXB0eT86IGJvb2xlYW5cbn0gPSB7fSk6IFZhbGlkYXRpb25SZXN1bHQge1xuICBjb25zdCB7XG4gICAgbWluTGVuZ3RoID0gMSxcbiAgICBtYXhMZW5ndGggPSAxMDAwMDAwLCAvLyAxTUIgb2YgdGV4dFxuICAgIHJlcXVpcmVkID0gdHJ1ZSxcbiAgICBhbGxvd0VtcHR5ID0gZmFsc2VcbiAgfSA9IG9wdGlvbnNcblxuICBpZiAocmVxdWlyZWQgJiYgIXRleHQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaXNWYWxpZDogZmFsc2UsXG4gICAgICBlcnJvcjogJ1RleHQgaXMgcmVxdWlyZWQnXG4gICAgfVxuICB9XG5cbiAgaWYgKCFhbGxvd0VtcHR5ICYmIHRleHQudHJpbSgpLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB7XG4gICAgICBpc1ZhbGlkOiBmYWxzZSxcbiAgICAgIGVycm9yOiAnVGV4dCBjYW5ub3QgYmUgZW1wdHknXG4gICAgfVxuICB9XG5cbiAgaWYgKHRleHQubGVuZ3RoIDwgbWluTGVuZ3RoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlzVmFsaWQ6IGZhbHNlLFxuICAgICAgZXJyb3I6IGBUZXh0IG11c3QgYmUgYXQgbGVhc3QgJHttaW5MZW5ndGh9IGNoYXJhY3RlcnMgbG9uZ2BcbiAgICB9XG4gIH1cblxuICBpZiAodGV4dC5sZW5ndGggPiBtYXhMZW5ndGgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaXNWYWxpZDogZmFsc2UsXG4gICAgICBlcnJvcjogYFRleHQgbXVzdCBub3QgZXhjZWVkICR7bWF4TGVuZ3RofSBjaGFyYWN0ZXJzYFxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHdhcm5pbmdzOiBzdHJpbmdbXSA9IFtdXG5cbiAgLy8gQ2hlY2sgZm9yIHN1c3BpY2lvdXMgY29udGVudFxuICBpZiAodGV4dC5pbmNsdWRlcygnPHNjcmlwdD4nKSB8fCB0ZXh0LmluY2x1ZGVzKCdqYXZhc2NyaXB0OicpKSB7XG4gICAgd2FybmluZ3MucHVzaCgnVGV4dCBjb250YWlucyBwb3RlbnRpYWxseSB1bnNhZmUgY29udGVudCcpXG4gIH1cblxuICAvLyBDaGVjayBmb3IgdmVyeSByZXBldGl0aXZlIGNvbnRlbnRcbiAgY29uc3Qgd29yZHMgPSB0ZXh0LnNwbGl0KC9cXHMrLylcbiAgY29uc3QgdW5pcXVlV29yZHMgPSBuZXcgU2V0KHdvcmRzKVxuICBpZiAod29yZHMubGVuZ3RoID4gMTAwICYmIHVuaXF1ZVdvcmRzLnNpemUgLyB3b3Jkcy5sZW5ndGggPCAwLjEpIHtcbiAgICB3YXJuaW5ncy5wdXNoKCdUZXh0IGFwcGVhcnMgdG8gYmUgdmVyeSByZXBldGl0aXZlJylcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgaXNWYWxpZDogdHJ1ZSxcbiAgICB3YXJuaW5nczogd2FybmluZ3MubGVuZ3RoID4gMCA/IHdhcm5pbmdzIDogdW5kZWZpbmVkXG4gIH1cbn1cblxuLy8gQVBJIHJlcXVlc3QgdmFsaWRhdGlvblxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlQXBpUmVxdWVzdChkYXRhOiBhbnksIHNjaGVtYToge1xuICByZXF1aXJlZEZpZWxkczogc3RyaW5nW11cbiAgb3B0aW9uYWxGaWVsZHM/OiBzdHJpbmdbXVxuICBtYXhTaXplPzogbnVtYmVyXG59KTogVmFsaWRhdGlvblJlc3VsdCB7XG4gIGNvbnN0IHsgcmVxdWlyZWRGaWVsZHMsIG9wdGlvbmFsRmllbGRzID0gW10sIG1heFNpemUgPSAxMCAqIDEwMjQgKiAxMDI0IH0gPSBzY2hlbWFcblxuICBpZiAoIWRhdGEgfHwgdHlwZW9mIGRhdGEgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlzVmFsaWQ6IGZhbHNlLFxuICAgICAgZXJyb3I6ICdSZXF1ZXN0IGRhdGEgbXVzdCBiZSBhbiBvYmplY3QnXG4gICAgfVxuICB9XG5cbiAgLy8gQ2hlY2sgcmVxdWlyZWQgZmllbGRzXG4gIGZvciAoY29uc3QgZmllbGQgb2YgcmVxdWlyZWRGaWVsZHMpIHtcbiAgICBpZiAoIShmaWVsZCBpbiBkYXRhKSB8fCBkYXRhW2ZpZWxkXSA9PT0gdW5kZWZpbmVkIHx8IGRhdGFbZmllbGRdID09PSBudWxsKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpc1ZhbGlkOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6IGBSZXF1aXJlZCBmaWVsZCBcIiR7ZmllbGR9XCIgaXMgbWlzc2luZ2BcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBDaGVjayBmb3IgdW5leHBlY3RlZCBmaWVsZHNcbiAgY29uc3QgYWxsb3dlZEZpZWxkcyA9IFsuLi5yZXF1aXJlZEZpZWxkcywgLi4ub3B0aW9uYWxGaWVsZHNdXG4gIGNvbnN0IHVuZXhwZWN0ZWRGaWVsZHMgPSBPYmplY3Qua2V5cyhkYXRhKS5maWx0ZXIoa2V5ID0+ICFhbGxvd2VkRmllbGRzLmluY2x1ZGVzKGtleSkpXG4gIFxuICBpZiAodW5leHBlY3RlZEZpZWxkcy5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlzVmFsaWQ6IGZhbHNlLFxuICAgICAgZXJyb3I6IGBVbmV4cGVjdGVkIGZpZWxkczogJHt1bmV4cGVjdGVkRmllbGRzLmpvaW4oJywgJyl9YFxuICAgIH1cbiAgfVxuXG4gIC8vIENoZWNrIGRhdGEgc2l6ZVxuICBjb25zdCBkYXRhU2l6ZSA9IEpTT04uc3RyaW5naWZ5KGRhdGEpLmxlbmd0aFxuICBpZiAoZGF0YVNpemUgPiBtYXhTaXplKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlzVmFsaWQ6IGZhbHNlLFxuICAgICAgZXJyb3I6IGBSZXF1ZXN0IGRhdGEgc2l6ZSAoJHtmb3JtYXRGaWxlU2l6ZShkYXRhU2l6ZSl9KSBleGNlZWRzIG1heGltdW0gYWxsb3dlZCBzaXplICgke2Zvcm1hdEZpbGVTaXplKG1heFNpemUpfSlgXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHsgaXNWYWxpZDogdHJ1ZSB9XG59XG5cbi8vIFNhbml0aXplIHRleHQgaW5wdXRcbmV4cG9ydCBmdW5jdGlvbiBzYW5pdGl6ZVRleHQodGV4dDogc3RyaW5nKTogc3RyaW5nIHtcbiAgaWYgKCF0ZXh0KSByZXR1cm4gJydcblxuICByZXR1cm4gdGV4dFxuICAgIC8vIFJlbW92ZSBudWxsIGJ5dGVzXG4gICAgLnJlcGxhY2UoL1xcMC9nLCAnJylcbiAgICAvLyBOb3JtYWxpemUgd2hpdGVzcGFjZVxuICAgIC5yZXBsYWNlKC9cXHMrL2csICcgJylcbiAgICAvLyBUcmltXG4gICAgLnRyaW0oKVxuICAgIC8vIFJlbW92ZSBwb3RlbnRpYWxseSBkYW5nZXJvdXMgSFRNTC9KU1xuICAgIC5yZXBsYWNlKC88c2NyaXB0W14+XSo+W1xcc1xcU10qPzxcXC9zY3JpcHQ+L2dpLCAnJylcbiAgICAucmVwbGFjZSgvamF2YXNjcmlwdDovZ2ksICcnKVxuICAgIC5yZXBsYWNlKC9vblxcdytcXHMqPS9naSwgJycpXG59XG5cbi8vIFZhbGlkYXRlIHJpc2sgbGV2ZWxcbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZVJpc2tMZXZlbChyaXNrTGV2ZWw6IGFueSk6IHJpc2tMZXZlbCBpcyBSaXNrTGV2ZWwge1xuICByZXR1cm4gWydsb3cnLCAnbWVkaXVtJywgJ2hpZ2gnXS5pbmNsdWRlcyhyaXNrTGV2ZWwpXG59XG5cbi8vIFZhbGlkYXRlIGNsYXVzZSB0eXBlXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVDbGF1c2VUeXBlKGNsYXVzZVR5cGU6IGFueSk6IGNsYXVzZVR5cGUgaXMgQ2xhdXNlVHlwZSB7XG4gIHJldHVybiBbXG4gICAgJ3Rlcm1pbmF0aW9uJyxcbiAgICAncGF5bWVudCcsXG4gICAgJ2xpYWJpbGl0eScsXG4gICAgJ2NvbmZpZGVudGlhbGl0eScsXG4gICAgJ2ludGVsbGVjdHVhbF9wcm9wZXJ0eScsXG4gICAgJ2Rpc3B1dGVfcmVzb2x1dGlvbicsXG4gICAgJ2ZvcmNlX21hamV1cmUnLFxuICAgICdnb3Zlcm5pbmdfbGF3JyxcbiAgICAnYW1lbmRtZW50JyxcbiAgICAnYXNzaWdubWVudCcsXG4gICAgJ3dhcnJhbnR5JyxcbiAgICAnaW5kZW1uaWZpY2F0aW9uJyxcbiAgICAnY29tcGxpYW5jZScsXG4gICAgJ2RhdGFfcHJvdGVjdGlvbicsXG4gICAgJ290aGVyJ1xuICBdLmluY2x1ZGVzKGNsYXVzZVR5cGUpXG59XG5cbi8vIFZhbGlkYXRlIGVtYWlsIGZvcm1hdFxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlRW1haWwoZW1haWw6IHN0cmluZyk6IFZhbGlkYXRpb25SZXN1bHQge1xuICBjb25zdCBlbWFpbFJlZ2V4ID0gL15bXlxcc0BdK0BbXlxcc0BdK1xcLlteXFxzQF0rJC9cbiAgXG4gIGlmICghZW1haWwpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaXNWYWxpZDogZmFsc2UsXG4gICAgICBlcnJvcjogJ0VtYWlsIGlzIHJlcXVpcmVkJ1xuICAgIH1cbiAgfVxuXG4gIGlmICghZW1haWxSZWdleC50ZXN0KGVtYWlsKSkge1xuICAgIHJldHVybiB7XG4gICAgICBpc1ZhbGlkOiBmYWxzZSxcbiAgICAgIGVycm9yOiAnSW52YWxpZCBlbWFpbCBmb3JtYXQnXG4gICAgfVxuICB9XG5cbiAgaWYgKGVtYWlsLmxlbmd0aCA+IDI1NCkge1xuICAgIHJldHVybiB7XG4gICAgICBpc1ZhbGlkOiBmYWxzZSxcbiAgICAgIGVycm9yOiAnRW1haWwgaXMgdG9vIGxvbmcnXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHsgaXNWYWxpZDogdHJ1ZSB9XG59XG5cbi8vIFZhbGlkYXRlIFVSTCBmb3JtYXRcbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZVVybCh1cmw6IHN0cmluZyk6IFZhbGlkYXRpb25SZXN1bHQge1xuICBpZiAoIXVybCkge1xuICAgIHJldHVybiB7XG4gICAgICBpc1ZhbGlkOiBmYWxzZSxcbiAgICAgIGVycm9yOiAnVVJMIGlzIHJlcXVpcmVkJ1xuICAgIH1cbiAgfVxuXG4gIHRyeSB7XG4gICAgY29uc3QgdXJsT2JqID0gbmV3IFVSTCh1cmwpXG4gICAgXG4gICAgLy8gQ2hlY2sgcHJvdG9jb2xcbiAgICBpZiAoIVsnaHR0cDonLCAnaHR0cHM6J10uaW5jbHVkZXModXJsT2JqLnByb3RvY29sKSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaXNWYWxpZDogZmFsc2UsXG4gICAgICAgIGVycm9yOiAnVVJMIG11c3QgdXNlIEhUVFAgb3IgSFRUUFMgcHJvdG9jb2wnXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgaXNWYWxpZDogdHJ1ZSB9XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiB7XG4gICAgICBpc1ZhbGlkOiBmYWxzZSxcbiAgICAgIGVycm9yOiAnSW52YWxpZCBVUkwgZm9ybWF0J1xuICAgIH1cbiAgfVxufVxuXG4vLyBWYWxpZGF0ZSBKU09OIHN0cmluZ1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlSnNvbihqc29uU3RyaW5nOiBzdHJpbmcpOiBWYWxpZGF0aW9uUmVzdWx0IHtcbiAgaWYgKCFqc29uU3RyaW5nKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlzVmFsaWQ6IGZhbHNlLFxuICAgICAgZXJyb3I6ICdKU09OIHN0cmluZyBpcyByZXF1aXJlZCdcbiAgICB9XG4gIH1cblxuICB0cnkge1xuICAgIEpTT04ucGFyc2UoanNvblN0cmluZylcbiAgICByZXR1cm4geyBpc1ZhbGlkOiB0cnVlIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaXNWYWxpZDogZmFsc2UsXG4gICAgICBlcnJvcjogYEludmFsaWQgSlNPTjogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yJ31gXG4gICAgfVxuICB9XG59XG5cbi8vIFZhbGlkYXRlIGNvbmZpZGVuY2Ugc2NvcmVcbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUNvbmZpZGVuY2UoY29uZmlkZW5jZTogYW55KTogVmFsaWRhdGlvblJlc3VsdCB7XG4gIGlmICh0eXBlb2YgY29uZmlkZW5jZSAhPT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaXNWYWxpZDogZmFsc2UsXG4gICAgICBlcnJvcjogJ0NvbmZpZGVuY2UgbXVzdCBiZSBhIG51bWJlcidcbiAgICB9XG4gIH1cblxuICBpZiAoY29uZmlkZW5jZSA8IDAgfHwgY29uZmlkZW5jZSA+IDEpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaXNWYWxpZDogZmFsc2UsXG4gICAgICBlcnJvcjogJ0NvbmZpZGVuY2UgbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDEnXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHsgaXNWYWxpZDogdHJ1ZSB9XG59XG5cbi8vIEhlbHBlciBmdW5jdGlvbiB0byBmb3JtYXQgZmlsZSBzaXplXG5mdW5jdGlvbiBmb3JtYXRGaWxlU2l6ZShieXRlczogbnVtYmVyKTogc3RyaW5nIHtcbiAgaWYgKGJ5dGVzID09PSAwKSByZXR1cm4gJzAgQnl0ZXMnXG4gIFxuICBjb25zdCBrID0gMTAyNFxuICBjb25zdCBzaXplcyA9IFsnQnl0ZXMnLCAnS0InLCAnTUInLCAnR0InXVxuICBjb25zdCBpID0gTWF0aC5mbG9vcihNYXRoLmxvZyhieXRlcykgLyBNYXRoLmxvZyhrKSlcbiAgXG4gIHJldHVybiBwYXJzZUZsb2F0KChieXRlcyAvIE1hdGgucG93KGssIGkpKS50b0ZpeGVkKDIpKSArICcgJyArIHNpemVzW2ldXG59XG5cbi8vIEJhdGNoIHZhbGlkYXRpb24gZm9yIG11bHRpcGxlIGlucHV0c1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlQmF0Y2godmFsaWRhdGlvbnM6IEFycmF5PCgpID0+IFZhbGlkYXRpb25SZXN1bHQ+KTogVmFsaWRhdGlvblJlc3VsdCB7XG4gIGNvbnN0IGVycm9yczogc3RyaW5nW10gPSBbXVxuICBjb25zdCB3YXJuaW5nczogc3RyaW5nW10gPSBbXVxuXG4gIGZvciAoY29uc3QgdmFsaWRhdGUgb2YgdmFsaWRhdGlvbnMpIHtcbiAgICBjb25zdCByZXN1bHQgPSB2YWxpZGF0ZSgpXG4gICAgaWYgKCFyZXN1bHQuaXNWYWxpZCAmJiByZXN1bHQuZXJyb3IpIHtcbiAgICAgIGVycm9ycy5wdXNoKHJlc3VsdC5lcnJvcilcbiAgICB9XG4gICAgaWYgKHJlc3VsdC53YXJuaW5ncykge1xuICAgICAgd2FybmluZ3MucHVzaCguLi5yZXN1bHQud2FybmluZ3MpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBpc1ZhbGlkOiBlcnJvcnMubGVuZ3RoID09PSAwLFxuICAgIGVycm9yOiBlcnJvcnMubGVuZ3RoID4gMCA/IGVycm9ycy5qb2luKCc7ICcpIDogdW5kZWZpbmVkLFxuICAgIHdhcm5pbmdzOiB3YXJuaW5ncy5sZW5ndGggPiAwID8gd2FybmluZ3MgOiB1bmRlZmluZWRcbiAgfVxufVxuXG4vLyBDcmVhdGUgdmFsaWRhdGlvbiBzY2hlbWFcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVWYWxpZGF0aW9uU2NoZW1hPFQ+KHZhbGlkYXRvcnM6IHtcbiAgW0sgaW4ga2V5b2YgVF0/OiAodmFsdWU6IFRbS10pID0+IFZhbGlkYXRpb25SZXN1bHRcbn0pIHtcbiAgcmV0dXJuIChkYXRhOiBUKTogVmFsaWRhdGlvblJlc3VsdCA9PiB7XG4gICAgY29uc3QgZXJyb3JzOiBzdHJpbmdbXSA9IFtdXG4gICAgY29uc3Qgd2FybmluZ3M6IHN0cmluZ1tdID0gW11cblxuICAgIGZvciAoY29uc3QgW2tleSwgdmFsaWRhdG9yXSBvZiBPYmplY3QuZW50cmllcyh2YWxpZGF0b3JzKSkge1xuICAgICAgaWYgKHZhbGlkYXRvciAmJiBrZXkgaW4gZGF0YSkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB2YWxpZGF0b3IoKGRhdGEgYXMgYW55KVtrZXldKVxuICAgICAgICBpZiAoIXJlc3VsdC5pc1ZhbGlkICYmIHJlc3VsdC5lcnJvcikge1xuICAgICAgICAgIGVycm9ycy5wdXNoKGAke2tleX06ICR7cmVzdWx0LmVycm9yfWApXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdC53YXJuaW5ncykge1xuICAgICAgICAgIHdhcm5pbmdzLnB1c2goLi4ucmVzdWx0Lndhcm5pbmdzLm1hcCh3ID0+IGAke2tleX06ICR7d31gKSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBpc1ZhbGlkOiBlcnJvcnMubGVuZ3RoID09PSAwLFxuICAgICAgZXJyb3I6IGVycm9ycy5sZW5ndGggPiAwID8gZXJyb3JzLmpvaW4oJzsgJykgOiB1bmRlZmluZWQsXG4gICAgICB3YXJuaW5nczogd2FybmluZ3MubGVuZ3RoID4gMCA/IHdhcm5pbmdzIDogdW5kZWZpbmVkXG4gICAgfVxuICB9XG59Il0sIm5hbWVzIjpbIkFQUF9DT05GSUciLCJ2YWxpZGF0ZUZpbGUiLCJmaWxlIiwid2FybmluZ3MiLCJzaXplIiwibWF4RmlsZVNpemUiLCJpc1ZhbGlkIiwiZXJyb3IiLCJmb3JtYXRGaWxlU2l6ZSIsImZpbGVOYW1lIiwibmFtZSIsInRvTG93ZXJDYXNlIiwiZmlsZVR5cGUiLCJ0eXBlIiwidmFsaWRNaW1lVHlwZXMiLCJTZXQiLCJ2YWxpZEV4dGVuc2lvbnMiLCJpc1ZhbGlkTWltZVR5cGUiLCJoYXMiLCJoYXNWYWxpZEV4dGVuc2lvbiIsIkFycmF5IiwiZnJvbSIsInNvbWUiLCJleHQiLCJlbmRzV2l0aCIsImlzUG5nRmlsZSIsImluY2x1ZGVzIiwiaXNKcGVnRmlsZSIsImlzUGRmRmlsZSIsImlzV2VicEZpbGUiLCJpc1ZhbGlkVHlwZSIsInN1cHBvcnRlZEZvcm1hdHMiLCJqb2luIiwibGVuZ3RoIiwicHVzaCIsInByb2JsZW1hdGljQ2hhcnMiLCJ0ZXN0IiwidW5kZWZpbmVkIiwidmFsaWRhdGVUZXh0IiwidGV4dCIsIm9wdGlvbnMiLCJtaW5MZW5ndGgiLCJtYXhMZW5ndGgiLCJyZXF1aXJlZCIsImFsbG93RW1wdHkiLCJ0cmltIiwid29yZHMiLCJzcGxpdCIsInVuaXF1ZVdvcmRzIiwidmFsaWRhdGVBcGlSZXF1ZXN0IiwiZGF0YSIsInNjaGVtYSIsInJlcXVpcmVkRmllbGRzIiwib3B0aW9uYWxGaWVsZHMiLCJtYXhTaXplIiwiZmllbGQiLCJhbGxvd2VkRmllbGRzIiwidW5leHBlY3RlZEZpZWxkcyIsIk9iamVjdCIsImtleXMiLCJmaWx0ZXIiLCJrZXkiLCJkYXRhU2l6ZSIsIkpTT04iLCJzdHJpbmdpZnkiLCJzYW5pdGl6ZVRleHQiLCJyZXBsYWNlIiwidmFsaWRhdGVSaXNrTGV2ZWwiLCJyaXNrTGV2ZWwiLCJ2YWxpZGF0ZUNsYXVzZVR5cGUiLCJjbGF1c2VUeXBlIiwidmFsaWRhdGVFbWFpbCIsImVtYWlsIiwiZW1haWxSZWdleCIsInZhbGlkYXRlVXJsIiwidXJsIiwidXJsT2JqIiwiVVJMIiwicHJvdG9jb2wiLCJ2YWxpZGF0ZUpzb24iLCJqc29uU3RyaW5nIiwicGFyc2UiLCJFcnJvciIsIm1lc3NhZ2UiLCJ2YWxpZGF0ZUNvbmZpZGVuY2UiLCJjb25maWRlbmNlIiwiYnl0ZXMiLCJrIiwic2l6ZXMiLCJpIiwiTWF0aCIsImZsb29yIiwibG9nIiwicGFyc2VGbG9hdCIsInBvdyIsInRvRml4ZWQiLCJ2YWxpZGF0ZUJhdGNoIiwidmFsaWRhdGlvbnMiLCJlcnJvcnMiLCJ2YWxpZGF0ZSIsInJlc3VsdCIsImNyZWF0ZVZhbGlkYXRpb25TY2hlbWEiLCJ2YWxpZGF0b3JzIiwidmFsaWRhdG9yIiwiZW50cmllcyIsIm1hcCIsInciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./lib/validation.ts\n"));

/***/ })

});