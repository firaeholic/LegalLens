"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/upload",{

/***/ "./hooks/useFileUpload.ts":
/*!********************************!*\
  !*** ./hooks/useFileUpload.ts ***!
  \********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useFileUpload: function() { return /* binding */ useFileUpload; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _lib_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/utils */ \"./lib/utils.ts\");\n/* harmony import */ var _lib_validation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/validation */ \"./lib/validation.ts\");\n/* harmony import */ var _config_constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../config/constants */ \"./config/constants.ts\");\n// Custom hook for file upload functionality\n\n\n\n\nfunction useFileUpload() {\n    const [uploadedFile, setUploadedFile] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [isDragActive, setIsDragActive] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [uploadError, setUploadError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [isProcessing, setIsProcessing] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const fileInputRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const processFile = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (file)=>{\n        setIsProcessing(true);\n        setUploadError(null);\n        try {\n            // Enhanced file validation with detailed logging\n            _lib_utils__WEBPACK_IMPORTED_MODULE_1__.logger.info(\"Starting file validation\", {\n                fileName: file.name,\n                fileSize: file.size,\n                fileType: file.type,\n                lastModified: file.lastModified\n            }, \"useFileUpload\");\n            const validation = (0,_lib_validation__WEBPACK_IMPORTED_MODULE_2__.validateFile)(file);\n            if (!validation.isValid) {\n                const errorMessage = validation.error || \"Invalid file type or format\";\n                _lib_utils__WEBPACK_IMPORTED_MODULE_1__.logger.error(\"File validation failed\", {\n                    fileName: file.name,\n                    fileType: file.type,\n                    error: errorMessage,\n                    warnings: validation.warnings\n                }, \"useFileUpload\");\n                throw new Error(errorMessage);\n            }\n            if (validation.warnings && validation.warnings.length > 0) {\n                _lib_utils__WEBPACK_IMPORTED_MODULE_1__.logger.warn(\"File validation warnings\", {\n                    fileName: file.name,\n                    warnings: validation.warnings\n                }, \"useFileUpload\");\n            }\n            _lib_utils__WEBPACK_IMPORTED_MODULE_1__.logger.info(\"Processing uploaded file\", {\n                fileName: file.name,\n                fileSize: file.size,\n                fileType: file.type\n            }, \"useFileUpload\");\n            // Convert to base64 for processing\n            const base64 = await (0,_lib_utils__WEBPACK_IMPORTED_MODULE_1__.convertFileToBase64)(file);\n            const uploadedFile = {\n                file,\n                name: file.name,\n                size: file.size,\n                type: file.type,\n                base64,\n                uploadedAt: new Date()\n            };\n            setUploadedFile(uploadedFile);\n            _lib_utils__WEBPACK_IMPORTED_MODULE_1__.logger.info(\"File processed successfully\", {\n                fileName: file.name,\n                base64Length: base64.length\n            }, \"useFileUpload\");\n            return uploadedFile;\n        } catch (error) {\n            const errorMessage = error instanceof Error ? error.message : \"Failed to process file\";\n            setUploadError(errorMessage);\n            _lib_utils__WEBPACK_IMPORTED_MODULE_1__.logger.error(\"File processing failed\", error, \"useFileUpload\");\n            throw error;\n        } finally{\n            setIsProcessing(false);\n        }\n    }, []);\n    const handleFileSelect = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (files)=>{\n        const fileArray = Array.from(files);\n        if (fileArray.length === 0) {\n            return;\n        }\n        if (fileArray.length > 1) {\n            setUploadError(\"Please select only one file at a time\");\n            return;\n        }\n        const file = fileArray[0];\n        try {\n            await processFile(file);\n        } catch (error) {\n        // Error is already handled in processFile\n        }\n    }, [\n        processFile\n    ]);\n    const handleDrop = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (e)=>{\n        e.preventDefault();\n        setIsDragActive(false);\n        const files = e.dataTransfer.files;\n        await handleFileSelect(files);\n    }, [\n        handleFileSelect\n    ]);\n    const handleDragOver = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e)=>{\n        e.preventDefault();\n        setIsDragActive(true);\n    }, []);\n    const handleDragLeave = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e)=>{\n        e.preventDefault();\n        setIsDragActive(false);\n    }, []);\n    const handleInputChange = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (e)=>{\n        const files = e.target.files;\n        if (files) {\n            await handleFileSelect(files);\n        }\n    }, [\n        handleFileSelect\n    ]);\n    const openFileDialog = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        var _fileInputRef_current;\n        (_fileInputRef_current = fileInputRef.current) === null || _fileInputRef_current === void 0 ? void 0 : _fileInputRef_current.click();\n    }, []);\n    const clearFile = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        setUploadedFile(null);\n        setUploadError(null);\n        setIsProcessing(false);\n        // Reset file input\n        if (fileInputRef.current) {\n            fileInputRef.current.value = \"\";\n        }\n        _lib_utils__WEBPACK_IMPORTED_MODULE_1__.logger.info(\"File cleared\", {}, \"useFileUpload\");\n    }, []);\n    const retryUpload = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async ()=>{\n        if (uploadedFile === null || uploadedFile === void 0 ? void 0 : uploadedFile.file) {\n            try {\n                await processFile(uploadedFile.file);\n            } catch (error) {\n            // Error is already handled in processFile\n            }\n        }\n    }, [\n        uploadedFile === null || uploadedFile === void 0 ? void 0 : uploadedFile.file,\n        processFile\n    ]);\n    // Get file preview URL for images\n    const getPreviewUrl = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        if (!(uploadedFile === null || uploadedFile === void 0 ? void 0 : uploadedFile.file)) return null;\n        if (uploadedFile.file.type.startsWith(\"image/\")) {\n            return URL.createObjectURL(uploadedFile.file);\n        }\n        return null;\n    }, [\n        uploadedFile === null || uploadedFile === void 0 ? void 0 : uploadedFile.file\n    ]);\n    // Get file icon based on type\n    const getFileIcon = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        if (!(uploadedFile === null || uploadedFile === void 0 ? void 0 : uploadedFile.type)) return \"file\";\n        if (uploadedFile.type === \"application/pdf\") return \"file-text\";\n        if (uploadedFile.type.startsWith(\"image/\")) return \"image\";\n        if (uploadedFile.type.includes(\"word\")) return \"file-text\";\n        if (uploadedFile.type.includes(\"text\")) return \"file-text\";\n        return \"file\";\n    }, [\n        uploadedFile === null || uploadedFile === void 0 ? void 0 : uploadedFile.type\n    ]);\n    // Check if file type is supported\n    const isFileTypeSupported = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((file)=>{\n        return _config_constants__WEBPACK_IMPORTED_MODULE_3__.APP_CONFIG.supportedFormats.some((format)=>{\n            if (format.startsWith(\".\")) {\n                return file.name.toLowerCase().endsWith(format.toLowerCase());\n            }\n            return file.type === format;\n        });\n    }, []);\n    // Get upload progress (for future enhancement)\n    const getUploadProgress = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        if (isProcessing) return 50 // Simulated progress\n        ;\n        if (uploadedFile) return 100;\n        return 0;\n    }, [\n        isProcessing,\n        uploadedFile\n    ]);\n    return {\n        uploadedFile,\n        isDragActive,\n        uploadError,\n        isProcessing,\n        fileInputRef,\n        handleDrop,\n        handleDragOver,\n        handleDragLeave,\n        handleInputChange,\n        openFileDialog,\n        clearFile,\n        retryUpload,\n        getPreviewUrl,\n        getFileIcon,\n        isFileTypeSupported,\n        getUploadProgress\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUN2QyxPQUFPWix5REFBVUEsQ0FBQzRELGdCQUFnQixDQUFDQyxJQUFJLENBQUNDLENBQUFBO1lBQ3RDLElBQUlBLE9BQU9SLFVBQVUsQ0FBQyxNQUFNO2dCQUMxQixPQUFPMUMsS0FBS0csSUFBSSxDQUFDZ0QsV0FBVyxHQUFHQyxRQUFRLENBQUNGLE9BQU9DLFdBQVc7WUFDNUQ7WUFDQSxPQUFPbkQsS0FBS08sSUFBSSxLQUFLMkM7UUFDdkI7SUFDRixHQUFHLEVBQUU7SUFFTCwrQ0FBK0M7SUFDL0MsTUFBTUcsb0JBQW9CdEUsa0RBQVdBLENBQUM7UUFDcEMsSUFBSWEsY0FBYyxPQUFPLEdBQUcscUJBQXFCOztRQUNqRCxJQUFJTixjQUFjLE9BQU87UUFDekIsT0FBTztJQUNULEdBQUc7UUFBQ007UUFBY047S0FBYTtJQUUvQixPQUFPO1FBQ0xBO1FBQ0FFO1FBQ0FFO1FBQ0FFO1FBQ0FFO1FBQ0E2QjtRQUNBSTtRQUNBQztRQUNBQztRQUNBRTtRQUNBRztRQUNBRTtRQUNBQztRQUNBSTtRQUNBRTtRQUNBTTtJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vaG9va3MvdXNlRmlsZVVwbG9hZC50cz8wM2MwIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEN1c3RvbSBob29rIGZvciBmaWxlIHVwbG9hZCBmdW5jdGlvbmFsaXR5XG5pbXBvcnQgeyB1c2VTdGF0ZSwgdXNlQ2FsbGJhY2ssIHVzZVJlZiB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHR5cGUgeyBVcGxvYWRlZEZpbGUsIFVzZUZpbGVVcGxvYWRSZXR1cm4gfSBmcm9tICcuLi90eXBlcydcbmltcG9ydCB7IGxvZ2dlciwgY29udmVydEZpbGVUb0Jhc2U2NCB9IGZyb20gJy4uL2xpYi91dGlscydcbmltcG9ydCB7IHZhbGlkYXRlRmlsZSB9IGZyb20gJy4uL2xpYi92YWxpZGF0aW9uJ1xuaW1wb3J0IHsgQVBQX0NPTkZJRyB9IGZyb20gJy4uL2NvbmZpZy9jb25zdGFudHMnXG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VGaWxlVXBsb2FkKCk6IFVzZUZpbGVVcGxvYWRSZXR1cm4ge1xuICBjb25zdCBbdXBsb2FkZWRGaWxlLCBzZXRVcGxvYWRlZEZpbGVdID0gdXNlU3RhdGU8VXBsb2FkZWRGaWxlIHwgbnVsbD4obnVsbClcbiAgY29uc3QgW2lzRHJhZ0FjdGl2ZSwgc2V0SXNEcmFnQWN0aXZlXSA9IHVzZVN0YXRlKGZhbHNlKVxuICBjb25zdCBbdXBsb2FkRXJyb3IsIHNldFVwbG9hZEVycm9yXSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpXG4gIGNvbnN0IFtpc1Byb2Nlc3NpbmcsIHNldElzUHJvY2Vzc2luZ10gPSB1c2VTdGF0ZShmYWxzZSlcbiAgY29uc3QgZmlsZUlucHV0UmVmID0gdXNlUmVmPEhUTUxJbnB1dEVsZW1lbnQ+KG51bGwpXG5cbiAgY29uc3QgcHJvY2Vzc0ZpbGUgPSB1c2VDYWxsYmFjayhhc3luYyAoZmlsZTogRmlsZSk6IFByb21pc2U8VXBsb2FkZWRGaWxlPiA9PiB7XG4gICAgc2V0SXNQcm9jZXNzaW5nKHRydWUpXG4gICAgc2V0VXBsb2FkRXJyb3IobnVsbClcblxuICAgIHRyeSB7XG4gICAgICAvLyBFbmhhbmNlZCBmaWxlIHZhbGlkYXRpb24gd2l0aCBkZXRhaWxlZCBsb2dnaW5nXG4gICAgICBsb2dnZXIuaW5mbygnU3RhcnRpbmcgZmlsZSB2YWxpZGF0aW9uJywge1xuICAgICAgICBmaWxlTmFtZTogZmlsZS5uYW1lLFxuICAgICAgICBmaWxlU2l6ZTogZmlsZS5zaXplLFxuICAgICAgICBmaWxlVHlwZTogZmlsZS50eXBlLFxuICAgICAgICBsYXN0TW9kaWZpZWQ6IGZpbGUubGFzdE1vZGlmaWVkXG4gICAgICB9LCAndXNlRmlsZVVwbG9hZCcpXG4gICAgICBcbiAgICAgIGNvbnN0IHZhbGlkYXRpb24gPSB2YWxpZGF0ZUZpbGUoZmlsZSlcbiAgICAgIGlmICghdmFsaWRhdGlvbi5pc1ZhbGlkKSB7XG4gICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IHZhbGlkYXRpb24uZXJyb3IgfHwgJ0ludmFsaWQgZmlsZSB0eXBlIG9yIGZvcm1hdCdcbiAgICAgICAgbG9nZ2VyLmVycm9yKCdGaWxlIHZhbGlkYXRpb24gZmFpbGVkJywge1xuICAgICAgICAgIGZpbGVOYW1lOiBmaWxlLm5hbWUsXG4gICAgICAgICAgZmlsZVR5cGU6IGZpbGUudHlwZSxcbiAgICAgICAgICBlcnJvcjogZXJyb3JNZXNzYWdlLFxuICAgICAgICAgIHdhcm5pbmdzOiB2YWxpZGF0aW9uLndhcm5pbmdzXG4gICAgICAgIH0sICd1c2VGaWxlVXBsb2FkJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yTWVzc2FnZSlcbiAgICAgIH1cbiAgICAgIFxuICAgICAgaWYgKHZhbGlkYXRpb24ud2FybmluZ3MgJiYgdmFsaWRhdGlvbi53YXJuaW5ncy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGxvZ2dlci53YXJuKCdGaWxlIHZhbGlkYXRpb24gd2FybmluZ3MnLCB7XG4gICAgICAgICAgZmlsZU5hbWU6IGZpbGUubmFtZSxcbiAgICAgICAgICB3YXJuaW5nczogdmFsaWRhdGlvbi53YXJuaW5nc1xuICAgICAgICB9LCAndXNlRmlsZVVwbG9hZCcpXG4gICAgICB9XG5cbiAgICAgIGxvZ2dlci5pbmZvKCdQcm9jZXNzaW5nIHVwbG9hZGVkIGZpbGUnLCB7XG4gICAgICAgIGZpbGVOYW1lOiBmaWxlLm5hbWUsXG4gICAgICAgIGZpbGVTaXplOiBmaWxlLnNpemUsXG4gICAgICAgIGZpbGVUeXBlOiBmaWxlLnR5cGVcbiAgICAgIH0sICd1c2VGaWxlVXBsb2FkJylcblxuICAgICAgLy8gQ29udmVydCB0byBiYXNlNjQgZm9yIHByb2Nlc3NpbmdcbiAgICAgIGNvbnN0IGJhc2U2NCA9IGF3YWl0IGNvbnZlcnRGaWxlVG9CYXNlNjQoZmlsZSlcbiAgICAgIFxuICAgICAgY29uc3QgdXBsb2FkZWRGaWxlOiBVcGxvYWRlZEZpbGUgPSB7XG4gICAgICAgIGZpbGUsXG4gICAgICAgIG5hbWU6IGZpbGUubmFtZSxcbiAgICAgICAgc2l6ZTogZmlsZS5zaXplLFxuICAgICAgICB0eXBlOiBmaWxlLnR5cGUsXG4gICAgICAgIGJhc2U2NCxcbiAgICAgICAgdXBsb2FkZWRBdDogbmV3IERhdGUoKVxuICAgICAgfVxuXG4gICAgICBzZXRVcGxvYWRlZEZpbGUodXBsb2FkZWRGaWxlKVxuICAgICAgXG4gICAgICBsb2dnZXIuaW5mbygnRmlsZSBwcm9jZXNzZWQgc3VjY2Vzc2Z1bGx5Jywge1xuICAgICAgICBmaWxlTmFtZTogZmlsZS5uYW1lLFxuICAgICAgICBiYXNlNjRMZW5ndGg6IGJhc2U2NC5sZW5ndGhcbiAgICAgIH0sICd1c2VGaWxlVXBsb2FkJylcblxuICAgICAgcmV0dXJuIHVwbG9hZGVkRmlsZVxuXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ0ZhaWxlZCB0byBwcm9jZXNzIGZpbGUnXG4gICAgICBzZXRVcGxvYWRFcnJvcihlcnJvck1lc3NhZ2UpXG4gICAgICBsb2dnZXIuZXJyb3IoJ0ZpbGUgcHJvY2Vzc2luZyBmYWlsZWQnLCBlcnJvciwgJ3VzZUZpbGVVcGxvYWQnKVxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9IGZpbmFsbHkge1xuICAgICAgc2V0SXNQcm9jZXNzaW5nKGZhbHNlKVxuICAgIH1cbiAgfSwgW10pXG5cbiAgY29uc3QgaGFuZGxlRmlsZVNlbGVjdCA9IHVzZUNhbGxiYWNrKGFzeW5jIChmaWxlczogRmlsZUxpc3QgfCBGaWxlW10pID0+IHtcbiAgICBjb25zdCBmaWxlQXJyYXkgPSBBcnJheS5mcm9tKGZpbGVzKVxuICAgIFxuICAgIGlmIChmaWxlQXJyYXkubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoZmlsZUFycmF5Lmxlbmd0aCA+IDEpIHtcbiAgICAgIHNldFVwbG9hZEVycm9yKCdQbGVhc2Ugc2VsZWN0IG9ubHkgb25lIGZpbGUgYXQgYSB0aW1lJylcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IGZpbGUgPSBmaWxlQXJyYXlbMF1cbiAgICBcbiAgICB0cnkge1xuICAgICAgYXdhaXQgcHJvY2Vzc0ZpbGUoZmlsZSlcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgLy8gRXJyb3IgaXMgYWxyZWFkeSBoYW5kbGVkIGluIHByb2Nlc3NGaWxlXG4gICAgfVxuICB9LCBbcHJvY2Vzc0ZpbGVdKVxuXG4gIGNvbnN0IGhhbmRsZURyb3AgPSB1c2VDYWxsYmFjayhhc3luYyAoZTogUmVhY3QuRHJhZ0V2ZW50PEhUTUxEaXZFbGVtZW50PikgPT4ge1xuICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgIHNldElzRHJhZ0FjdGl2ZShmYWxzZSlcbiAgICBcbiAgICBjb25zdCBmaWxlcyA9IGUuZGF0YVRyYW5zZmVyLmZpbGVzXG4gICAgYXdhaXQgaGFuZGxlRmlsZVNlbGVjdChmaWxlcylcbiAgfSwgW2hhbmRsZUZpbGVTZWxlY3RdKVxuXG4gIGNvbnN0IGhhbmRsZURyYWdPdmVyID0gdXNlQ2FsbGJhY2soKGU6IFJlYWN0LkRyYWdFdmVudDxIVE1MRGl2RWxlbWVudD4pID0+IHtcbiAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICBzZXRJc0RyYWdBY3RpdmUodHJ1ZSlcbiAgfSwgW10pXG5cbiAgY29uc3QgaGFuZGxlRHJhZ0xlYXZlID0gdXNlQ2FsbGJhY2soKGU6IFJlYWN0LkRyYWdFdmVudDxIVE1MRGl2RWxlbWVudD4pID0+IHtcbiAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICBzZXRJc0RyYWdBY3RpdmUoZmFsc2UpXG4gIH0sIFtdKVxuXG4gIGNvbnN0IGhhbmRsZUlucHV0Q2hhbmdlID0gdXNlQ2FsbGJhY2soYXN5bmMgKGU6IFJlYWN0LkNoYW5nZUV2ZW50PEhUTUxJbnB1dEVsZW1lbnQ+KSA9PiB7XG4gICAgY29uc3QgZmlsZXMgPSBlLnRhcmdldC5maWxlc1xuICAgIGlmIChmaWxlcykge1xuICAgICAgYXdhaXQgaGFuZGxlRmlsZVNlbGVjdChmaWxlcylcbiAgICB9XG4gIH0sIFtoYW5kbGVGaWxlU2VsZWN0XSlcblxuICBjb25zdCBvcGVuRmlsZURpYWxvZyA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBmaWxlSW5wdXRSZWYuY3VycmVudD8uY2xpY2soKVxuICB9LCBbXSlcblxuICBjb25zdCBjbGVhckZpbGUgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgc2V0VXBsb2FkZWRGaWxlKG51bGwpXG4gICAgc2V0VXBsb2FkRXJyb3IobnVsbClcbiAgICBzZXRJc1Byb2Nlc3NpbmcoZmFsc2UpXG4gICAgXG4gICAgLy8gUmVzZXQgZmlsZSBpbnB1dFxuICAgIGlmIChmaWxlSW5wdXRSZWYuY3VycmVudCkge1xuICAgICAgZmlsZUlucHV0UmVmLmN1cnJlbnQudmFsdWUgPSAnJ1xuICAgIH1cblxuICAgIGxvZ2dlci5pbmZvKCdGaWxlIGNsZWFyZWQnLCB7fSwgJ3VzZUZpbGVVcGxvYWQnKVxuICB9LCBbXSlcblxuICBjb25zdCByZXRyeVVwbG9hZCA9IHVzZUNhbGxiYWNrKGFzeW5jICgpID0+IHtcbiAgICBpZiAodXBsb2FkZWRGaWxlPy5maWxlKSB7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCBwcm9jZXNzRmlsZSh1cGxvYWRlZEZpbGUuZmlsZSlcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIC8vIEVycm9yIGlzIGFscmVhZHkgaGFuZGxlZCBpbiBwcm9jZXNzRmlsZVxuICAgICAgfVxuICAgIH1cbiAgfSwgW3VwbG9hZGVkRmlsZT8uZmlsZSwgcHJvY2Vzc0ZpbGVdKVxuXG4gIC8vIEdldCBmaWxlIHByZXZpZXcgVVJMIGZvciBpbWFnZXNcbiAgY29uc3QgZ2V0UHJldmlld1VybCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBpZiAoIXVwbG9hZGVkRmlsZT8uZmlsZSkgcmV0dXJuIG51bGxcbiAgICBcbiAgICBpZiAodXBsb2FkZWRGaWxlLmZpbGUudHlwZS5zdGFydHNXaXRoKCdpbWFnZS8nKSkge1xuICAgICAgcmV0dXJuIFVSTC5jcmVhdGVPYmplY3RVUkwodXBsb2FkZWRGaWxlLmZpbGUpXG4gICAgfVxuICAgIFxuICAgIHJldHVybiBudWxsXG4gIH0sIFt1cGxvYWRlZEZpbGU/LmZpbGVdKVxuXG4gIC8vIEdldCBmaWxlIGljb24gYmFzZWQgb24gdHlwZVxuICBjb25zdCBnZXRGaWxlSWNvbiA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBpZiAoIXVwbG9hZGVkRmlsZT8udHlwZSkgcmV0dXJuICdmaWxlJ1xuICAgIFxuICAgIGlmICh1cGxvYWRlZEZpbGUudHlwZSA9PT0gJ2FwcGxpY2F0aW9uL3BkZicpIHJldHVybiAnZmlsZS10ZXh0J1xuICAgIGlmICh1cGxvYWRlZEZpbGUudHlwZS5zdGFydHNXaXRoKCdpbWFnZS8nKSkgcmV0dXJuICdpbWFnZSdcbiAgICBpZiAodXBsb2FkZWRGaWxlLnR5cGUuaW5jbHVkZXMoJ3dvcmQnKSkgcmV0dXJuICdmaWxlLXRleHQnXG4gICAgaWYgKHVwbG9hZGVkRmlsZS50eXBlLmluY2x1ZGVzKCd0ZXh0JykpIHJldHVybiAnZmlsZS10ZXh0J1xuICAgIFxuICAgIHJldHVybiAnZmlsZSdcbiAgfSwgW3VwbG9hZGVkRmlsZT8udHlwZV0pXG5cbiAgLy8gQ2hlY2sgaWYgZmlsZSB0eXBlIGlzIHN1cHBvcnRlZFxuICBjb25zdCBpc0ZpbGVUeXBlU3VwcG9ydGVkID0gdXNlQ2FsbGJhY2soKGZpbGU6IEZpbGUpID0+IHtcbiAgICByZXR1cm4gQVBQX0NPTkZJRy5zdXBwb3J0ZWRGb3JtYXRzLnNvbWUoZm9ybWF0ID0+IHtcbiAgICAgIGlmIChmb3JtYXQuc3RhcnRzV2l0aCgnLicpKSB7XG4gICAgICAgIHJldHVybiBmaWxlLm5hbWUudG9Mb3dlckNhc2UoKS5lbmRzV2l0aChmb3JtYXQudG9Mb3dlckNhc2UoKSlcbiAgICAgIH1cbiAgICAgIHJldHVybiBmaWxlLnR5cGUgPT09IGZvcm1hdFxuICAgIH0pXG4gIH0sIFtdKVxuXG4gIC8vIEdldCB1cGxvYWQgcHJvZ3Jlc3MgKGZvciBmdXR1cmUgZW5oYW5jZW1lbnQpXG4gIGNvbnN0IGdldFVwbG9hZFByb2dyZXNzID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGlmIChpc1Byb2Nlc3NpbmcpIHJldHVybiA1MCAvLyBTaW11bGF0ZWQgcHJvZ3Jlc3NcbiAgICBpZiAodXBsb2FkZWRGaWxlKSByZXR1cm4gMTAwXG4gICAgcmV0dXJuIDBcbiAgfSwgW2lzUHJvY2Vzc2luZywgdXBsb2FkZWRGaWxlXSlcblxuICByZXR1cm4ge1xuICAgIHVwbG9hZGVkRmlsZSxcbiAgICBpc0RyYWdBY3RpdmUsXG4gICAgdXBsb2FkRXJyb3IsXG4gICAgaXNQcm9jZXNzaW5nLFxuICAgIGZpbGVJbnB1dFJlZixcbiAgICBoYW5kbGVEcm9wLFxuICAgIGhhbmRsZURyYWdPdmVyLFxuICAgIGhhbmRsZURyYWdMZWF2ZSxcbiAgICBoYW5kbGVJbnB1dENoYW5nZSxcbiAgICBvcGVuRmlsZURpYWxvZyxcbiAgICBjbGVhckZpbGUsXG4gICAgcmV0cnlVcGxvYWQsXG4gICAgZ2V0UHJldmlld1VybCxcbiAgICBnZXRGaWxlSWNvbixcbiAgICBpc0ZpbGVUeXBlU3VwcG9ydGVkLFxuICAgIGdldFVwbG9hZFByb2dyZXNzXG4gIH1cbn0iXSwibmFtZXMiOlsidXNlU3RhdGUiLCJ1c2VDYWxsYmFjayIsInVzZVJlZiIsImxvZ2dlciIsImNvbnZlcnRGaWxlVG9CYXNlNjQiLCJ2YWxpZGF0ZUZpbGUiLCJBUFBfQ09ORklHIiwidXNlRmlsZVVwbG9hZCIsInVwbG9hZGVkRmlsZSIsInNldFVwbG9hZGVkRmlsZSIsImlzRHJhZ0FjdGl2ZSIsInNldElzRHJhZ0FjdGl2ZSIsInVwbG9hZEVycm9yIiwic2V0VXBsb2FkRXJyb3IiLCJpc1Byb2Nlc3NpbmciLCJzZXRJc1Byb2Nlc3NpbmciLCJmaWxlSW5wdXRSZWYiLCJwcm9jZXNzRmlsZSIsImZpbGUiLCJpbmZvIiwiZmlsZU5hbWUiLCJuYW1lIiwiZmlsZVNpemUiLCJzaXplIiwiZmlsZVR5cGUiLCJ0eXBlIiwibGFzdE1vZGlmaWVkIiwidmFsaWRhdGlvbiIsImlzVmFsaWQiLCJlcnJvck1lc3NhZ2UiLCJlcnJvciIsIndhcm5pbmdzIiwiRXJyb3IiLCJsZW5ndGgiLCJ3YXJuIiwiYmFzZTY0IiwidXBsb2FkZWRBdCIsIkRhdGUiLCJiYXNlNjRMZW5ndGgiLCJtZXNzYWdlIiwiaGFuZGxlRmlsZVNlbGVjdCIsImZpbGVzIiwiZmlsZUFycmF5IiwiQXJyYXkiLCJmcm9tIiwiaGFuZGxlRHJvcCIsImUiLCJwcmV2ZW50RGVmYXVsdCIsImRhdGFUcmFuc2ZlciIsImhhbmRsZURyYWdPdmVyIiwiaGFuZGxlRHJhZ0xlYXZlIiwiaGFuZGxlSW5wdXRDaGFuZ2UiLCJ0YXJnZXQiLCJvcGVuRmlsZURpYWxvZyIsImN1cnJlbnQiLCJjbGljayIsImNsZWFyRmlsZSIsInZhbHVlIiwicmV0cnlVcGxvYWQiLCJnZXRQcmV2aWV3VXJsIiwic3RhcnRzV2l0aCIsIlVSTCIsImNyZWF0ZU9iamVjdFVSTCIsImdldEZpbGVJY29uIiwiaW5jbHVkZXMiLCJpc0ZpbGVUeXBlU3VwcG9ydGVkIiwic3VwcG9ydGVkRm9ybWF0cyIsInNvbWUiLCJmb3JtYXQiLCJ0b0xvd2VyQ2FzZSIsImVuZHNXaXRoIiwiZ2V0VXBsb2FkUHJvZ3Jlc3MiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./hooks/useFileUpload.ts\n"));

/***/ }),

/***/ "./lib/validation.ts":
/*!***************************!*\
  !*** ./lib/validation.ts ***!
  \***************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createValidationSchema: function() { return /* binding */ createValidationSchema; },\n/* harmony export */   sanitizeText: function() { return /* binding */ sanitizeText; },\n/* harmony export */   validateApiRequest: function() { return /* binding */ validateApiRequest; },\n/* harmony export */   validateBatch: function() { return /* binding */ validateBatch; },\n/* harmony export */   validateClauseType: function() { return /* binding */ validateClauseType; },\n/* harmony export */   validateConfidence: function() { return /* binding */ validateConfidence; },\n/* harmony export */   validateEmail: function() { return /* binding */ validateEmail; },\n/* harmony export */   validateFile: function() { return /* binding */ validateFile; },\n/* harmony export */   validateJson: function() { return /* binding */ validateJson; },\n/* harmony export */   validateRiskLevel: function() { return /* binding */ validateRiskLevel; },\n/* harmony export */   validateText: function() { return /* binding */ validateText; },\n/* harmony export */   validateUrl: function() { return /* binding */ validateUrl; }\n/* harmony export */ });\n/* harmony import */ var _config_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../config/constants */ \"./config/constants.ts\");\n// Input validation utilities\n\n// File validation\nfunction validateFile(file) {\n    const warnings = [];\n    // Check file size\n    if (file.size > _config_constants__WEBPACK_IMPORTED_MODULE_0__.APP_CONFIG.maxFileSize) {\n        return {\n            isValid: false,\n            error: \"File size (\".concat(formatFileSize(file.size), \") exceeds maximum allowed size (\").concat(formatFileSize(_config_constants__WEBPACK_IMPORTED_MODULE_0__.APP_CONFIG.maxFileSize), \")\")\n        };\n    }\n    // Check file type with comprehensive validation\n    const fileName = file.name.toLowerCase();\n    const fileType = file.type.toLowerCase();\n    // Define comprehensive MIME type mappings\n    const validMimeTypes = new Set([\n        \"application/pdf\",\n        \"image/png\",\n        \"image/jpeg\",\n        \"image/jpg\",\n        \"image/webp\"\n    ]);\n    // Define valid file extensions\n    const validExtensions = new Set([\n        \".pdf\",\n        \".png\",\n        \".jpg\",\n        \".jpeg\",\n        \".webp\"\n    ]);\n    // Check by MIME type first\n    const isValidMimeType = validMimeTypes.has(fileType);\n    // Check by file extension as fallback\n    const hasValidExtension = validExtensions.some((ext)=>fileName.endsWith(ext));\n    // Additional check for common PNG variations\n    const isPngFile = fileType.includes(\"png\") || fileName.endsWith(\".png\");\n    const isJpegFile = fileType.includes(\"jpeg\") || fileType.includes(\"jpg\") || fileName.endsWith(\".jpg\") || fileName.endsWith(\".jpeg\");\n    const isPdfFile = fileType.includes(\"pdf\") || fileName.endsWith(\".pdf\");\n    const isWebpFile = fileType.includes(\"webp\") || fileName.endsWith(\".webp\");\n    const isValidType = isValidMimeType || hasValidExtension || isPngFile || isJpegFile || isPdfFile || isWebpFile;\n    if (!isValidType) {\n        return {\n            isValid: false,\n            error: 'File type \"'.concat(file.type || \"unknown\", '\" is not supported. Supported formats: ').concat(_config_constants__WEBPACK_IMPORTED_MODULE_0__.APP_CONFIG.supportedFormats.join(\", \"))\n        };\n    }\n    // Check file name\n    if (file.name.length > 255) {\n        warnings.push(\"File name is very long and may cause issues\");\n    }\n    // Check for potentially problematic characters\n    const problematicChars = /[<>:\"|?*\\x00-\\x1f]/;\n    if (problematicChars.test(file.name)) {\n        warnings.push(\"File name contains special characters that may cause issues\");\n    }\n    // Warn about very small files\n    if (file.size < 100) {\n        warnings.push(\"File is very small and may not contain meaningful content\");\n    }\n    return {\n        isValid: true,\n        warnings: warnings.length > 0 ? warnings : undefined\n    };\n}\n// Text validation\nfunction validateText(text) {\n    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    const { minLength = 1, maxLength = 1000000, required = true, allowEmpty = false } = options;\n    if (required && !text) {\n        return {\n            isValid: false,\n            error: \"Text is required\"\n        };\n    }\n    if (!allowEmpty && text.trim().length === 0) {\n        return {\n            isValid: false,\n            error: \"Text cannot be empty\"\n        };\n    }\n    if (text.length < minLength) {\n        return {\n            isValid: false,\n            error: \"Text must be at least \".concat(minLength, \" characters long\")\n        };\n    }\n    if (text.length > maxLength) {\n        return {\n            isValid: false,\n            error: \"Text must not exceed \".concat(maxLength, \" characters\")\n        };\n    }\n    const warnings = [];\n    // Check for suspicious content\n    if (text.includes(\"<script>\") || text.includes(\"javascript:\")) {\n        warnings.push(\"Text contains potentially unsafe content\");\n    }\n    // Check for very repetitive content\n    const words = text.split(/\\s+/);\n    const uniqueWords = new Set(words);\n    if (words.length > 100 && uniqueWords.size / words.length < 0.1) {\n        warnings.push(\"Text appears to be very repetitive\");\n    }\n    return {\n        isValid: true,\n        warnings: warnings.length > 0 ? warnings : undefined\n    };\n}\n// API request validation\nfunction validateApiRequest(data, schema) {\n    const { requiredFields, optionalFields = [], maxSize = 10 * 1024 * 1024 } = schema;\n    if (!data || typeof data !== \"object\") {\n        return {\n            isValid: false,\n            error: \"Request data must be an object\"\n        };\n    }\n    // Check required fields\n    for (const field of requiredFields){\n        if (!(field in data) || data[field] === undefined || data[field] === null) {\n            return {\n                isValid: false,\n                error: 'Required field \"'.concat(field, '\" is missing')\n            };\n        }\n    }\n    // Check for unexpected fields\n    const allowedFields = [\n        ...requiredFields,\n        ...optionalFields\n    ];\n    const unexpectedFields = Object.keys(data).filter((key)=>!allowedFields.includes(key));\n    if (unexpectedFields.length > 0) {\n        return {\n            isValid: false,\n            error: \"Unexpected fields: \".concat(unexpectedFields.join(\", \"))\n        };\n    }\n    // Check data size\n    const dataSize = JSON.stringify(data).length;\n    if (dataSize > maxSize) {\n        return {\n            isValid: false,\n            error: \"Request data size (\".concat(formatFileSize(dataSize), \") exceeds maximum allowed size (\").concat(formatFileSize(maxSize), \")\")\n        };\n    }\n    return {\n        isValid: true\n    };\n}\n// Sanitize text input\nfunction sanitizeText(text) {\n    if (!text) return \"\";\n    return text// Remove null bytes\n    .replace(/\\0/g, \"\")// Normalize whitespace\n    .replace(/\\s+/g, \" \")// Trim\n    .trim()// Remove potentially dangerous HTML/JS\n    .replace(/<script[^>]*>[\\s\\S]*?<\\/script>/gi, \"\").replace(/javascript:/gi, \"\").replace(/on\\w+\\s*=/gi, \"\");\n}\n// Validate risk level\nfunction validateRiskLevel(riskLevel) {\n    return [\n        \"low\",\n        \"medium\",\n        \"high\"\n    ].includes(riskLevel);\n}\n// Validate clause type\nfunction validateClauseType(clauseType) {\n    return [\n        \"termination\",\n        \"payment\",\n        \"liability\",\n        \"confidentiality\",\n        \"intellectual_property\",\n        \"dispute_resolution\",\n        \"force_majeure\",\n        \"governing_law\",\n        \"amendment\",\n        \"assignment\",\n        \"warranty\",\n        \"indemnification\",\n        \"compliance\",\n        \"data_protection\",\n        \"other\"\n    ].includes(clauseType);\n}\n// Validate email format\nfunction validateEmail(email) {\n    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n    if (!email) {\n        return {\n            isValid: false,\n            error: \"Email is required\"\n        };\n    }\n    if (!emailRegex.test(email)) {\n        return {\n            isValid: false,\n            error: \"Invalid email format\"\n        };\n    }\n    if (email.length > 254) {\n        return {\n            isValid: false,\n            error: \"Email is too long\"\n        };\n    }\n    return {\n        isValid: true\n    };\n}\n// Validate URL format\nfunction validateUrl(url) {\n    if (!url) {\n        return {\n            isValid: false,\n            error: \"URL is required\"\n        };\n    }\n    try {\n        const urlObj = new URL(url);\n        // Check protocol\n        if (![\n            \"http:\",\n            \"https:\"\n        ].includes(urlObj.protocol)) {\n            return {\n                isValid: false,\n                error: \"URL must use HTTP or HTTPS protocol\"\n            };\n        }\n        return {\n            isValid: true\n        };\n    } catch (e) {\n        return {\n            isValid: false,\n            error: \"Invalid URL format\"\n        };\n    }\n}\n// Validate JSON string\nfunction validateJson(jsonString) {\n    if (!jsonString) {\n        return {\n            isValid: false,\n            error: \"JSON string is required\"\n        };\n    }\n    try {\n        JSON.parse(jsonString);\n        return {\n            isValid: true\n        };\n    } catch (error) {\n        return {\n            isValid: false,\n            error: \"Invalid JSON: \".concat(error instanceof Error ? error.message : \"Unknown error\")\n        };\n    }\n}\n// Validate confidence score\nfunction validateConfidence(confidence) {\n    if (typeof confidence !== \"number\") {\n        return {\n            isValid: false,\n            error: \"Confidence must be a number\"\n        };\n    }\n    if (confidence < 0 || confidence > 1) {\n        return {\n            isValid: false,\n            error: \"Confidence must be between 0 and 1\"\n        };\n    }\n    return {\n        isValid: true\n    };\n}\n// Helper function to format file size\nfunction formatFileSize(bytes) {\n    if (bytes === 0) return \"0 Bytes\";\n    const k = 1024;\n    const sizes = [\n        \"Bytes\",\n        \"KB\",\n        \"MB\",\n        \"GB\"\n    ];\n    const i = Math.floor(Math.log(bytes) / Math.log(k));\n    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + \" \" + sizes[i];\n}\n// Batch validation for multiple inputs\nfunction validateBatch(validations) {\n    const errors = [];\n    const warnings = [];\n    for (const validate of validations){\n        const result = validate();\n        if (!result.isValid && result.error) {\n            errors.push(result.error);\n        }\n        if (result.warnings) {\n            warnings.push(...result.warnings);\n        }\n    }\n    return {\n        isValid: errors.length === 0,\n        error: errors.length > 0 ? errors.join(\"; \") : undefined,\n        warnings: warnings.length > 0 ? warnings : undefined\n    };\n}\n// Create validation schema\nfunction createValidationSchema(validators) {\n    return (data)=>{\n        const errors = [];\n        const warnings = [];\n        for (const [key, validator] of Object.entries(validators)){\n            if (validator && key in data) {\n                const result = validator(data[key]);\n                if (!result.isValid && result.error) {\n                    errors.push(\"\".concat(key, \": \").concat(result.error));\n                }\n                if (result.warnings) {\n                    warnings.push(...result.warnings.map((w)=>\"\".concat(key, \": \").concat(w)));\n                }\n            }\n        }\n        return {\n            isValid: errors.length === 0,\n            error: errors.length > 0 ? errors.join(\"; \") : undefined,\n            warnings: warnings.length > 0 ? warnings : undefined\n        };\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFLO1lBQzNCeEIsT0FBT3lGLE9BQU9qRSxNQUFNLEdBQUcsSUFBSWlFLE9BQU9sRSxJQUFJLENBQUMsUUFBUUs7WUFDL0NoQyxVQUFVQSxTQUFTNEIsTUFBTSxHQUFHLElBQUk1QixXQUFXZ0M7UUFDN0M7SUFDRjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2xpYi92YWxpZGF0aW9uLnRzPzUwYWMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gSW5wdXQgdmFsaWRhdGlvbiB1dGlsaXRpZXNcbmltcG9ydCB7IEFQUF9DT05GSUcgfSBmcm9tICcuLi9jb25maWcvY29uc3RhbnRzJ1xuaW1wb3J0IHR5cGUgeyBSaXNrTGV2ZWwsIENsYXVzZVR5cGUgfSBmcm9tICcuLi90eXBlcydcblxuLy8gVmFsaWRhdGlvbiByZXN1bHQgaW50ZXJmYWNlXG5leHBvcnQgaW50ZXJmYWNlIFZhbGlkYXRpb25SZXN1bHQge1xuICBpc1ZhbGlkOiBib29sZWFuXG4gIGVycm9yPzogc3RyaW5nXG4gIHdhcm5pbmdzPzogc3RyaW5nW11cbn1cblxuLy8gRmlsZSB2YWxpZGF0aW9uXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVGaWxlKGZpbGU6IEZpbGUpOiBWYWxpZGF0aW9uUmVzdWx0IHtcbiAgY29uc3Qgd2FybmluZ3M6IHN0cmluZ1tdID0gW11cblxuICAvLyBDaGVjayBmaWxlIHNpemVcbiAgaWYgKGZpbGUuc2l6ZSA+IEFQUF9DT05GSUcubWF4RmlsZVNpemUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaXNWYWxpZDogZmFsc2UsXG4gICAgICBlcnJvcjogYEZpbGUgc2l6ZSAoJHtmb3JtYXRGaWxlU2l6ZShmaWxlLnNpemUpfSkgZXhjZWVkcyBtYXhpbXVtIGFsbG93ZWQgc2l6ZSAoJHtmb3JtYXRGaWxlU2l6ZShBUFBfQ09ORklHLm1heEZpbGVTaXplKX0pYFxuICAgIH1cbiAgfVxuXG4gIC8vIENoZWNrIGZpbGUgdHlwZSB3aXRoIGNvbXByZWhlbnNpdmUgdmFsaWRhdGlvblxuICBjb25zdCBmaWxlTmFtZSA9IGZpbGUubmFtZS50b0xvd2VyQ2FzZSgpXG4gIGNvbnN0IGZpbGVUeXBlID0gZmlsZS50eXBlLnRvTG93ZXJDYXNlKClcbiAgXG4gIC8vIERlZmluZSBjb21wcmVoZW5zaXZlIE1JTUUgdHlwZSBtYXBwaW5nc1xuICBjb25zdCB2YWxpZE1pbWVUeXBlcyA9IG5ldyBTZXQoW1xuICAgICdhcHBsaWNhdGlvbi9wZGYnLFxuICAgICdpbWFnZS9wbmcnLFxuICAgICdpbWFnZS9qcGVnJyxcbiAgICAnaW1hZ2UvanBnJyxcbiAgICAnaW1hZ2Uvd2VicCdcbiAgXSlcbiAgXG4gIC8vIERlZmluZSB2YWxpZCBmaWxlIGV4dGVuc2lvbnNcbiAgY29uc3QgdmFsaWRFeHRlbnNpb25zID0gbmV3IFNldChbJy5wZGYnLCAnLnBuZycsICcuanBnJywgJy5qcGVnJywgJy53ZWJwJ10pXG4gIFxuICAvLyBDaGVjayBieSBNSU1FIHR5cGUgZmlyc3RcbiAgY29uc3QgaXNWYWxpZE1pbWVUeXBlID0gdmFsaWRNaW1lVHlwZXMuaGFzKGZpbGVUeXBlKVxuICBcbiAgLy8gQ2hlY2sgYnkgZmlsZSBleHRlbnNpb24gYXMgZmFsbGJhY2tcbiAgY29uc3QgaGFzVmFsaWRFeHRlbnNpb24gPSB2YWxpZEV4dGVuc2lvbnMuc29tZShleHQgPT4gZmlsZU5hbWUuZW5kc1dpdGgoZXh0KSlcbiAgXG4gIC8vIEFkZGl0aW9uYWwgY2hlY2sgZm9yIGNvbW1vbiBQTkcgdmFyaWF0aW9uc1xuICBjb25zdCBpc1BuZ0ZpbGUgPSBmaWxlVHlwZS5pbmNsdWRlcygncG5nJykgfHwgZmlsZU5hbWUuZW5kc1dpdGgoJy5wbmcnKVxuICBjb25zdCBpc0pwZWdGaWxlID0gKGZpbGVUeXBlLmluY2x1ZGVzKCdqcGVnJykgfHwgZmlsZVR5cGUuaW5jbHVkZXMoJ2pwZycpKSB8fCBcbiAgICAgICAgICAgICAgICAgICAgKGZpbGVOYW1lLmVuZHNXaXRoKCcuanBnJykgfHwgZmlsZU5hbWUuZW5kc1dpdGgoJy5qcGVnJykpXG4gIGNvbnN0IGlzUGRmRmlsZSA9IGZpbGVUeXBlLmluY2x1ZGVzKCdwZGYnKSB8fCBmaWxlTmFtZS5lbmRzV2l0aCgnLnBkZicpXG4gIGNvbnN0IGlzV2VicEZpbGUgPSBmaWxlVHlwZS5pbmNsdWRlcygnd2VicCcpIHx8IGZpbGVOYW1lLmVuZHNXaXRoKCcud2VicCcpXG4gIFxuICBjb25zdCBpc1ZhbGlkVHlwZSA9IGlzVmFsaWRNaW1lVHlwZSB8fCBoYXNWYWxpZEV4dGVuc2lvbiB8fCBpc1BuZ0ZpbGUgfHwgaXNKcGVnRmlsZSB8fCBpc1BkZkZpbGUgfHwgaXNXZWJwRmlsZVxuXG4gIGlmICghaXNWYWxpZFR5cGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaXNWYWxpZDogZmFsc2UsXG4gICAgICBlcnJvcjogYEZpbGUgdHlwZSBcIiR7ZmlsZS50eXBlIHx8ICd1bmtub3duJ31cIiBpcyBub3Qgc3VwcG9ydGVkLiBTdXBwb3J0ZWQgZm9ybWF0czogJHtBUFBfQ09ORklHLnN1cHBvcnRlZEZvcm1hdHMuam9pbignLCAnKX1gXG4gICAgfVxuICB9XG5cbiAgLy8gQ2hlY2sgZmlsZSBuYW1lXG4gIGlmIChmaWxlLm5hbWUubGVuZ3RoID4gMjU1KSB7XG4gICAgd2FybmluZ3MucHVzaCgnRmlsZSBuYW1lIGlzIHZlcnkgbG9uZyBhbmQgbWF5IGNhdXNlIGlzc3VlcycpXG4gIH1cblxuICAvLyBDaGVjayBmb3IgcG90ZW50aWFsbHkgcHJvYmxlbWF0aWMgY2hhcmFjdGVyc1xuICBjb25zdCBwcm9ibGVtYXRpY0NoYXJzID0gL1s8PjpcInw/KlxceDAwLVxceDFmXS9cbiAgaWYgKHByb2JsZW1hdGljQ2hhcnMudGVzdChmaWxlLm5hbWUpKSB7XG4gICAgd2FybmluZ3MucHVzaCgnRmlsZSBuYW1lIGNvbnRhaW5zIHNwZWNpYWwgY2hhcmFjdGVycyB0aGF0IG1heSBjYXVzZSBpc3N1ZXMnKVxuICB9XG5cbiAgLy8gV2FybiBhYm91dCB2ZXJ5IHNtYWxsIGZpbGVzXG4gIGlmIChmaWxlLnNpemUgPCAxMDApIHtcbiAgICB3YXJuaW5ncy5wdXNoKCdGaWxlIGlzIHZlcnkgc21hbGwgYW5kIG1heSBub3QgY29udGFpbiBtZWFuaW5nZnVsIGNvbnRlbnQnKVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBpc1ZhbGlkOiB0cnVlLFxuICAgIHdhcm5pbmdzOiB3YXJuaW5ncy5sZW5ndGggPiAwID8gd2FybmluZ3MgOiB1bmRlZmluZWRcbiAgfVxufVxuXG4vLyBUZXh0IHZhbGlkYXRpb25cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZVRleHQodGV4dDogc3RyaW5nLCBvcHRpb25zOiB7XG4gIG1pbkxlbmd0aD86IG51bWJlclxuICBtYXhMZW5ndGg/OiBudW1iZXJcbiAgcmVxdWlyZWQ/OiBib29sZWFuXG4gIGFsbG93RW1wdHk/OiBib29sZWFuXG59ID0ge30pOiBWYWxpZGF0aW9uUmVzdWx0IHtcbiAgY29uc3Qge1xuICAgIG1pbkxlbmd0aCA9IDEsXG4gICAgbWF4TGVuZ3RoID0gMTAwMDAwMCwgLy8gMU1CIG9mIHRleHRcbiAgICByZXF1aXJlZCA9IHRydWUsXG4gICAgYWxsb3dFbXB0eSA9IGZhbHNlXG4gIH0gPSBvcHRpb25zXG5cbiAgaWYgKHJlcXVpcmVkICYmICF0ZXh0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlzVmFsaWQ6IGZhbHNlLFxuICAgICAgZXJyb3I6ICdUZXh0IGlzIHJlcXVpcmVkJ1xuICAgIH1cbiAgfVxuXG4gIGlmICghYWxsb3dFbXB0eSAmJiB0ZXh0LnRyaW0oKS5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4ge1xuICAgICAgaXNWYWxpZDogZmFsc2UsXG4gICAgICBlcnJvcjogJ1RleHQgY2Fubm90IGJlIGVtcHR5J1xuICAgIH1cbiAgfVxuXG4gIGlmICh0ZXh0Lmxlbmd0aCA8IG1pbkxlbmd0aCkge1xuICAgIHJldHVybiB7XG4gICAgICBpc1ZhbGlkOiBmYWxzZSxcbiAgICAgIGVycm9yOiBgVGV4dCBtdXN0IGJlIGF0IGxlYXN0ICR7bWluTGVuZ3RofSBjaGFyYWN0ZXJzIGxvbmdgXG4gICAgfVxuICB9XG5cbiAgaWYgKHRleHQubGVuZ3RoID4gbWF4TGVuZ3RoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlzVmFsaWQ6IGZhbHNlLFxuICAgICAgZXJyb3I6IGBUZXh0IG11c3Qgbm90IGV4Y2VlZCAke21heExlbmd0aH0gY2hhcmFjdGVyc2BcbiAgICB9XG4gIH1cblxuICBjb25zdCB3YXJuaW5nczogc3RyaW5nW10gPSBbXVxuXG4gIC8vIENoZWNrIGZvciBzdXNwaWNpb3VzIGNvbnRlbnRcbiAgaWYgKHRleHQuaW5jbHVkZXMoJzxzY3JpcHQ+JykgfHwgdGV4dC5pbmNsdWRlcygnamF2YXNjcmlwdDonKSkge1xuICAgIHdhcm5pbmdzLnB1c2goJ1RleHQgY29udGFpbnMgcG90ZW50aWFsbHkgdW5zYWZlIGNvbnRlbnQnKVxuICB9XG5cbiAgLy8gQ2hlY2sgZm9yIHZlcnkgcmVwZXRpdGl2ZSBjb250ZW50XG4gIGNvbnN0IHdvcmRzID0gdGV4dC5zcGxpdCgvXFxzKy8pXG4gIGNvbnN0IHVuaXF1ZVdvcmRzID0gbmV3IFNldCh3b3JkcylcbiAgaWYgKHdvcmRzLmxlbmd0aCA+IDEwMCAmJiB1bmlxdWVXb3Jkcy5zaXplIC8gd29yZHMubGVuZ3RoIDwgMC4xKSB7XG4gICAgd2FybmluZ3MucHVzaCgnVGV4dCBhcHBlYXJzIHRvIGJlIHZlcnkgcmVwZXRpdGl2ZScpXG4gIH1cblxuICByZXR1cm4ge1xuICAgIGlzVmFsaWQ6IHRydWUsXG4gICAgd2FybmluZ3M6IHdhcm5pbmdzLmxlbmd0aCA+IDAgPyB3YXJuaW5ncyA6IHVuZGVmaW5lZFxuICB9XG59XG5cbi8vIEFQSSByZXF1ZXN0IHZhbGlkYXRpb25cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUFwaVJlcXVlc3QoZGF0YTogYW55LCBzY2hlbWE6IHtcbiAgcmVxdWlyZWRGaWVsZHM6IHN0cmluZ1tdXG4gIG9wdGlvbmFsRmllbGRzPzogc3RyaW5nW11cbiAgbWF4U2l6ZT86IG51bWJlclxufSk6IFZhbGlkYXRpb25SZXN1bHQge1xuICBjb25zdCB7IHJlcXVpcmVkRmllbGRzLCBvcHRpb25hbEZpZWxkcyA9IFtdLCBtYXhTaXplID0gMTAgKiAxMDI0ICogMTAyNCB9ID0gc2NoZW1hXG5cbiAgaWYgKCFkYXRhIHx8IHR5cGVvZiBkYXRhICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiB7XG4gICAgICBpc1ZhbGlkOiBmYWxzZSxcbiAgICAgIGVycm9yOiAnUmVxdWVzdCBkYXRhIG11c3QgYmUgYW4gb2JqZWN0J1xuICAgIH1cbiAgfVxuXG4gIC8vIENoZWNrIHJlcXVpcmVkIGZpZWxkc1xuICBmb3IgKGNvbnN0IGZpZWxkIG9mIHJlcXVpcmVkRmllbGRzKSB7XG4gICAgaWYgKCEoZmllbGQgaW4gZGF0YSkgfHwgZGF0YVtmaWVsZF0gPT09IHVuZGVmaW5lZCB8fCBkYXRhW2ZpZWxkXSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaXNWYWxpZDogZmFsc2UsXG4gICAgICAgIGVycm9yOiBgUmVxdWlyZWQgZmllbGQgXCIke2ZpZWxkfVwiIGlzIG1pc3NpbmdgXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gQ2hlY2sgZm9yIHVuZXhwZWN0ZWQgZmllbGRzXG4gIGNvbnN0IGFsbG93ZWRGaWVsZHMgPSBbLi4ucmVxdWlyZWRGaWVsZHMsIC4uLm9wdGlvbmFsRmllbGRzXVxuICBjb25zdCB1bmV4cGVjdGVkRmllbGRzID0gT2JqZWN0LmtleXMoZGF0YSkuZmlsdGVyKGtleSA9PiAhYWxsb3dlZEZpZWxkcy5pbmNsdWRlcyhrZXkpKVxuICBcbiAgaWYgKHVuZXhwZWN0ZWRGaWVsZHMubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiB7XG4gICAgICBpc1ZhbGlkOiBmYWxzZSxcbiAgICAgIGVycm9yOiBgVW5leHBlY3RlZCBmaWVsZHM6ICR7dW5leHBlY3RlZEZpZWxkcy5qb2luKCcsICcpfWBcbiAgICB9XG4gIH1cblxuICAvLyBDaGVjayBkYXRhIHNpemVcbiAgY29uc3QgZGF0YVNpemUgPSBKU09OLnN0cmluZ2lmeShkYXRhKS5sZW5ndGhcbiAgaWYgKGRhdGFTaXplID4gbWF4U2l6ZSkge1xuICAgIHJldHVybiB7XG4gICAgICBpc1ZhbGlkOiBmYWxzZSxcbiAgICAgIGVycm9yOiBgUmVxdWVzdCBkYXRhIHNpemUgKCR7Zm9ybWF0RmlsZVNpemUoZGF0YVNpemUpfSkgZXhjZWVkcyBtYXhpbXVtIGFsbG93ZWQgc2l6ZSAoJHtmb3JtYXRGaWxlU2l6ZShtYXhTaXplKX0pYFxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7IGlzVmFsaWQ6IHRydWUgfVxufVxuXG4vLyBTYW5pdGl6ZSB0ZXh0IGlucHV0XG5leHBvcnQgZnVuY3Rpb24gc2FuaXRpemVUZXh0KHRleHQ6IHN0cmluZyk6IHN0cmluZyB7XG4gIGlmICghdGV4dCkgcmV0dXJuICcnXG5cbiAgcmV0dXJuIHRleHRcbiAgICAvLyBSZW1vdmUgbnVsbCBieXRlc1xuICAgIC5yZXBsYWNlKC9cXDAvZywgJycpXG4gICAgLy8gTm9ybWFsaXplIHdoaXRlc3BhY2VcbiAgICAucmVwbGFjZSgvXFxzKy9nLCAnICcpXG4gICAgLy8gVHJpbVxuICAgIC50cmltKClcbiAgICAvLyBSZW1vdmUgcG90ZW50aWFsbHkgZGFuZ2Vyb3VzIEhUTUwvSlNcbiAgICAucmVwbGFjZSgvPHNjcmlwdFtePl0qPltcXHNcXFNdKj88XFwvc2NyaXB0Pi9naSwgJycpXG4gICAgLnJlcGxhY2UoL2phdmFzY3JpcHQ6L2dpLCAnJylcbiAgICAucmVwbGFjZSgvb25cXHcrXFxzKj0vZ2ksICcnKVxufVxuXG4vLyBWYWxpZGF0ZSByaXNrIGxldmVsXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVSaXNrTGV2ZWwocmlza0xldmVsOiBhbnkpOiByaXNrTGV2ZWwgaXMgUmlza0xldmVsIHtcbiAgcmV0dXJuIFsnbG93JywgJ21lZGl1bScsICdoaWdoJ10uaW5jbHVkZXMocmlza0xldmVsKVxufVxuXG4vLyBWYWxpZGF0ZSBjbGF1c2UgdHlwZVxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlQ2xhdXNlVHlwZShjbGF1c2VUeXBlOiBhbnkpOiBjbGF1c2VUeXBlIGlzIENsYXVzZVR5cGUge1xuICByZXR1cm4gW1xuICAgICd0ZXJtaW5hdGlvbicsXG4gICAgJ3BheW1lbnQnLFxuICAgICdsaWFiaWxpdHknLFxuICAgICdjb25maWRlbnRpYWxpdHknLFxuICAgICdpbnRlbGxlY3R1YWxfcHJvcGVydHknLFxuICAgICdkaXNwdXRlX3Jlc29sdXRpb24nLFxuICAgICdmb3JjZV9tYWpldXJlJyxcbiAgICAnZ292ZXJuaW5nX2xhdycsXG4gICAgJ2FtZW5kbWVudCcsXG4gICAgJ2Fzc2lnbm1lbnQnLFxuICAgICd3YXJyYW50eScsXG4gICAgJ2luZGVtbmlmaWNhdGlvbicsXG4gICAgJ2NvbXBsaWFuY2UnLFxuICAgICdkYXRhX3Byb3RlY3Rpb24nLFxuICAgICdvdGhlcidcbiAgXS5pbmNsdWRlcyhjbGF1c2VUeXBlKVxufVxuXG4vLyBWYWxpZGF0ZSBlbWFpbCBmb3JtYXRcbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUVtYWlsKGVtYWlsOiBzdHJpbmcpOiBWYWxpZGF0aW9uUmVzdWx0IHtcbiAgY29uc3QgZW1haWxSZWdleCA9IC9eW15cXHNAXStAW15cXHNAXStcXC5bXlxcc0BdKyQvXG4gIFxuICBpZiAoIWVtYWlsKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlzVmFsaWQ6IGZhbHNlLFxuICAgICAgZXJyb3I6ICdFbWFpbCBpcyByZXF1aXJlZCdcbiAgICB9XG4gIH1cblxuICBpZiAoIWVtYWlsUmVnZXgudGVzdChlbWFpbCkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaXNWYWxpZDogZmFsc2UsXG4gICAgICBlcnJvcjogJ0ludmFsaWQgZW1haWwgZm9ybWF0J1xuICAgIH1cbiAgfVxuXG4gIGlmIChlbWFpbC5sZW5ndGggPiAyNTQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaXNWYWxpZDogZmFsc2UsXG4gICAgICBlcnJvcjogJ0VtYWlsIGlzIHRvbyBsb25nJ1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7IGlzVmFsaWQ6IHRydWUgfVxufVxuXG4vLyBWYWxpZGF0ZSBVUkwgZm9ybWF0XG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVVcmwodXJsOiBzdHJpbmcpOiBWYWxpZGF0aW9uUmVzdWx0IHtcbiAgaWYgKCF1cmwpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaXNWYWxpZDogZmFsc2UsXG4gICAgICBlcnJvcjogJ1VSTCBpcyByZXF1aXJlZCdcbiAgICB9XG4gIH1cblxuICB0cnkge1xuICAgIGNvbnN0IHVybE9iaiA9IG5ldyBVUkwodXJsKVxuICAgIFxuICAgIC8vIENoZWNrIHByb3RvY29sXG4gICAgaWYgKCFbJ2h0dHA6JywgJ2h0dHBzOiddLmluY2x1ZGVzKHVybE9iai5wcm90b2NvbCkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlzVmFsaWQ6IGZhbHNlLFxuICAgICAgICBlcnJvcjogJ1VSTCBtdXN0IHVzZSBIVFRQIG9yIEhUVFBTIHByb3RvY29sJ1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7IGlzVmFsaWQ6IHRydWUgfVxuICB9IGNhdGNoIHtcbiAgICByZXR1cm4ge1xuICAgICAgaXNWYWxpZDogZmFsc2UsXG4gICAgICBlcnJvcjogJ0ludmFsaWQgVVJMIGZvcm1hdCdcbiAgICB9XG4gIH1cbn1cblxuLy8gVmFsaWRhdGUgSlNPTiBzdHJpbmdcbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUpzb24oanNvblN0cmluZzogc3RyaW5nKTogVmFsaWRhdGlvblJlc3VsdCB7XG4gIGlmICghanNvblN0cmluZykge1xuICAgIHJldHVybiB7XG4gICAgICBpc1ZhbGlkOiBmYWxzZSxcbiAgICAgIGVycm9yOiAnSlNPTiBzdHJpbmcgaXMgcmVxdWlyZWQnXG4gICAgfVxuICB9XG5cbiAgdHJ5IHtcbiAgICBKU09OLnBhcnNlKGpzb25TdHJpbmcpXG4gICAgcmV0dXJuIHsgaXNWYWxpZDogdHJ1ZSB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlzVmFsaWQ6IGZhbHNlLFxuICAgICAgZXJyb3I6IGBJbnZhbGlkIEpTT046ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcid9YFxuICAgIH1cbiAgfVxufVxuXG4vLyBWYWxpZGF0ZSBjb25maWRlbmNlIHNjb3JlXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVDb25maWRlbmNlKGNvbmZpZGVuY2U6IGFueSk6IFZhbGlkYXRpb25SZXN1bHQge1xuICBpZiAodHlwZW9mIGNvbmZpZGVuY2UgIT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlzVmFsaWQ6IGZhbHNlLFxuICAgICAgZXJyb3I6ICdDb25maWRlbmNlIG11c3QgYmUgYSBudW1iZXInXG4gICAgfVxuICB9XG5cbiAgaWYgKGNvbmZpZGVuY2UgPCAwIHx8IGNvbmZpZGVuY2UgPiAxKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlzVmFsaWQ6IGZhbHNlLFxuICAgICAgZXJyb3I6ICdDb25maWRlbmNlIG11c3QgYmUgYmV0d2VlbiAwIGFuZCAxJ1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7IGlzVmFsaWQ6IHRydWUgfVxufVxuXG4vLyBIZWxwZXIgZnVuY3Rpb24gdG8gZm9ybWF0IGZpbGUgc2l6ZVxuZnVuY3Rpb24gZm9ybWF0RmlsZVNpemUoYnl0ZXM6IG51bWJlcik6IHN0cmluZyB7XG4gIGlmIChieXRlcyA9PT0gMCkgcmV0dXJuICcwIEJ5dGVzJ1xuICBcbiAgY29uc3QgayA9IDEwMjRcbiAgY29uc3Qgc2l6ZXMgPSBbJ0J5dGVzJywgJ0tCJywgJ01CJywgJ0dCJ11cbiAgY29uc3QgaSA9IE1hdGguZmxvb3IoTWF0aC5sb2coYnl0ZXMpIC8gTWF0aC5sb2coaykpXG4gIFxuICByZXR1cm4gcGFyc2VGbG9hdCgoYnl0ZXMgLyBNYXRoLnBvdyhrLCBpKSkudG9GaXhlZCgyKSkgKyAnICcgKyBzaXplc1tpXVxufVxuXG4vLyBCYXRjaCB2YWxpZGF0aW9uIGZvciBtdWx0aXBsZSBpbnB1dHNcbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUJhdGNoKHZhbGlkYXRpb25zOiBBcnJheTwoKSA9PiBWYWxpZGF0aW9uUmVzdWx0Pik6IFZhbGlkYXRpb25SZXN1bHQge1xuICBjb25zdCBlcnJvcnM6IHN0cmluZ1tdID0gW11cbiAgY29uc3Qgd2FybmluZ3M6IHN0cmluZ1tdID0gW11cblxuICBmb3IgKGNvbnN0IHZhbGlkYXRlIG9mIHZhbGlkYXRpb25zKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdmFsaWRhdGUoKVxuICAgIGlmICghcmVzdWx0LmlzVmFsaWQgJiYgcmVzdWx0LmVycm9yKSB7XG4gICAgICBlcnJvcnMucHVzaChyZXN1bHQuZXJyb3IpXG4gICAgfVxuICAgIGlmIChyZXN1bHQud2FybmluZ3MpIHtcbiAgICAgIHdhcm5pbmdzLnB1c2goLi4ucmVzdWx0Lndhcm5pbmdzKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgaXNWYWxpZDogZXJyb3JzLmxlbmd0aCA9PT0gMCxcbiAgICBlcnJvcjogZXJyb3JzLmxlbmd0aCA+IDAgPyBlcnJvcnMuam9pbignOyAnKSA6IHVuZGVmaW5lZCxcbiAgICB3YXJuaW5nczogd2FybmluZ3MubGVuZ3RoID4gMCA/IHdhcm5pbmdzIDogdW5kZWZpbmVkXG4gIH1cbn1cblxuLy8gQ3JlYXRlIHZhbGlkYXRpb24gc2NoZW1hXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlVmFsaWRhdGlvblNjaGVtYTxUPih2YWxpZGF0b3JzOiB7XG4gIFtLIGluIGtleW9mIFRdPzogKHZhbHVlOiBUW0tdKSA9PiBWYWxpZGF0aW9uUmVzdWx0XG59KSB7XG4gIHJldHVybiAoZGF0YTogVCk6IFZhbGlkYXRpb25SZXN1bHQgPT4ge1xuICAgIGNvbnN0IGVycm9yczogc3RyaW5nW10gPSBbXVxuICAgIGNvbnN0IHdhcm5pbmdzOiBzdHJpbmdbXSA9IFtdXG5cbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbGlkYXRvcl0gb2YgT2JqZWN0LmVudHJpZXModmFsaWRhdG9ycykpIHtcbiAgICAgIGlmICh2YWxpZGF0b3IgJiYga2V5IGluIGRhdGEpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdmFsaWRhdG9yKChkYXRhIGFzIGFueSlba2V5XSlcbiAgICAgICAgaWYgKCFyZXN1bHQuaXNWYWxpZCAmJiByZXN1bHQuZXJyb3IpIHtcbiAgICAgICAgICBlcnJvcnMucHVzaChgJHtrZXl9OiAke3Jlc3VsdC5lcnJvcn1gKVxuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQud2FybmluZ3MpIHtcbiAgICAgICAgICB3YXJuaW5ncy5wdXNoKC4uLnJlc3VsdC53YXJuaW5ncy5tYXAodyA9PiBgJHtrZXl9OiAke3d9YCkpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgaXNWYWxpZDogZXJyb3JzLmxlbmd0aCA9PT0gMCxcbiAgICAgIGVycm9yOiBlcnJvcnMubGVuZ3RoID4gMCA/IGVycm9ycy5qb2luKCc7ICcpIDogdW5kZWZpbmVkLFxuICAgICAgd2FybmluZ3M6IHdhcm5pbmdzLmxlbmd0aCA+IDAgPyB3YXJuaW5ncyA6IHVuZGVmaW5lZFxuICAgIH1cbiAgfVxufSJdLCJuYW1lcyI6WyJBUFBfQ09ORklHIiwidmFsaWRhdGVGaWxlIiwiZmlsZSIsIndhcm5pbmdzIiwic2l6ZSIsIm1heEZpbGVTaXplIiwiaXNWYWxpZCIsImVycm9yIiwiZm9ybWF0RmlsZVNpemUiLCJmaWxlTmFtZSIsIm5hbWUiLCJ0b0xvd2VyQ2FzZSIsImZpbGVUeXBlIiwidHlwZSIsInZhbGlkTWltZVR5cGVzIiwiU2V0IiwidmFsaWRFeHRlbnNpb25zIiwiaXNWYWxpZE1pbWVUeXBlIiwiaGFzIiwiaGFzVmFsaWRFeHRlbnNpb24iLCJzb21lIiwiZXh0IiwiZW5kc1dpdGgiLCJpc1BuZ0ZpbGUiLCJpbmNsdWRlcyIsImlzSnBlZ0ZpbGUiLCJpc1BkZkZpbGUiLCJpc1dlYnBGaWxlIiwiaXNWYWxpZFR5cGUiLCJzdXBwb3J0ZWRGb3JtYXRzIiwiam9pbiIsImxlbmd0aCIsInB1c2giLCJwcm9ibGVtYXRpY0NoYXJzIiwidGVzdCIsInVuZGVmaW5lZCIsInZhbGlkYXRlVGV4dCIsInRleHQiLCJvcHRpb25zIiwibWluTGVuZ3RoIiwibWF4TGVuZ3RoIiwicmVxdWlyZWQiLCJhbGxvd0VtcHR5IiwidHJpbSIsIndvcmRzIiwic3BsaXQiLCJ1bmlxdWVXb3JkcyIsInZhbGlkYXRlQXBpUmVxdWVzdCIsImRhdGEiLCJzY2hlbWEiLCJyZXF1aXJlZEZpZWxkcyIsIm9wdGlvbmFsRmllbGRzIiwibWF4U2l6ZSIsImZpZWxkIiwiYWxsb3dlZEZpZWxkcyIsInVuZXhwZWN0ZWRGaWVsZHMiLCJPYmplY3QiLCJrZXlzIiwiZmlsdGVyIiwia2V5IiwiZGF0YVNpemUiLCJKU09OIiwic3RyaW5naWZ5Iiwic2FuaXRpemVUZXh0IiwicmVwbGFjZSIsInZhbGlkYXRlUmlza0xldmVsIiwicmlza0xldmVsIiwidmFsaWRhdGVDbGF1c2VUeXBlIiwiY2xhdXNlVHlwZSIsInZhbGlkYXRlRW1haWwiLCJlbWFpbCIsImVtYWlsUmVnZXgiLCJ2YWxpZGF0ZVVybCIsInVybCIsInVybE9iaiIsIlVSTCIsInByb3RvY29sIiwidmFsaWRhdGVKc29uIiwianNvblN0cmluZyIsInBhcnNlIiwiRXJyb3IiLCJtZXNzYWdlIiwidmFsaWRhdGVDb25maWRlbmNlIiwiY29uZmlkZW5jZSIsImJ5dGVzIiwiayIsInNpemVzIiwiaSIsIk1hdGgiLCJmbG9vciIsImxvZyIsInBhcnNlRmxvYXQiLCJwb3ciLCJ0b0ZpeGVkIiwidmFsaWRhdGVCYXRjaCIsInZhbGlkYXRpb25zIiwiZXJyb3JzIiwidmFsaWRhdGUiLCJyZXN1bHQiLCJjcmVhdGVWYWxpZGF0aW9uU2NoZW1hIiwidmFsaWRhdG9ycyIsInZhbGlkYXRvciIsImVudHJpZXMiLCJtYXAiLCJ3Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./lib/validation.ts\n"));

/***/ })

});